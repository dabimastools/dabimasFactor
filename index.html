<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>ダビふぁく</title>
    <link rel="manifest" href="./manifest.json" />
    <link href="./css/loading.css" type="text/css" rel="stylesheet" />
    <link href="./css/style.css" type="text/css" rel="stylesheet" />
    <link href="./css/factor-dialog.css" type="text/css" rel="stylesheet" />
    <link href="./css/combinationDialog.css" type="text/css" rel="stylesheet" />

    <!-- <link
      href="https://cdn.jsdelivr.net/npm/@mdi/font@5.x/css/materialdesignicons.min.css"
      rel="stylesheet"
    /> -->
    <link
      href="./css/materialdesignicons.min.css"
      type="text/css"
      rel="stylesheet"
    />
    <link
      href="./css/vuetify_compact.min.css"
      type="text/css"
      rel="stylesheet"
    />
    <link rel="icon" href="./favicon.ico" sizes="any" />
    <!-- 32×32 -->
    <link rel="apple-touch-icon" href="./apple-touch-icon.png" />
    <!-- 180×180 -->
    <meta name="mobile-web-app-capable" content="yes" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"
    />
  </head>

  <body>
    <!-- ローディングアニメーション↓ -->
    <div id="loader">
      <div class="spinner">
        <div class="cube1"></div>
        <div class="cube2"></div>
      </div>
    </div>
    <!-- ローディングアニメーション↑ -->

    <!-- 非同期処理が完了した後に表示するコンテンツ -->
    <v-app id="app">
      <header>
        <table width="100%" style="border-collapse: collapse">
          <tbody v-if="$vuetify.breakpoint.mdAndUp">
            <tr>
              <th rowspan="3" class="f00_nitro_space"></th>
              <th width="1%" rowspan="3" class="f00_nitro">
                <span>ニトロ</span>
              </th>
              <th colspan="12" class="f00_nitro_header"></th>
              <th rowspan="3" class="f00_inbreed_space"></th>
              <th width="1%" rowspan="3" class="f00_inbreed" @click="handleClick()">
                <span>クロス</span>
              </th>
              <th colspan="12" class="f00_inbreed_header"></th>
              <th v-if="dispCategory % 2 === 0" rowspan="2" class="table_footer_TH_theory">理論</th>
              <th v-else rowspan="2" class="table_footer_TH_theory">子系統数</th>
              <th
                rowspan="3"
                width="3%"
                :style="combinationCellStyle"
                @click="handleCombinationCellClick"
              >
                <v-icon size="x-large" color="white">mdi-horse-variant</v-icon>
              </th>
              <th
                rowspan="3"
                width="3%"
                @click="initializer()"
                style="background-color: #aa0000; cursor: pointer"
              >
                <v-icon size="x-large" color="white">mdi-reload</v-icon>
              </th>
            </tr>
            <tr class="f00">
              <th width="1%" class="f01">短</th>
              <th class="f02">速</th>
              <th class="f03">底</th>
              <th class="f04">長</th>
              <th class="f05">適</th>
              <th class="f06">丈</th>
              <th class="f07">早</th>
              <th class="f08">晩</th>
              <th class="f09">堅</th>
              <th class="f10">難</th>
              <th class="f11">走</th>
              <th class="f12">中</th>
              <th class="f01">短</th>
              <th class="f02">速</th>
              <th class="f03">底</th>
              <th class="f04">長</th>
              <th class="f05">適</th>
              <th class="f06">丈</th>
              <th class="f07">早</th>
              <th class="f08">晩</th>
              <th class="f09">堅</th>
              <th class="f10">難</th>
              <th class="f11">走</th>
              <th class="f12">中</th>
            </tr>
            <tr>
              <th class="factorNumCell">{{factorNumtoString[0]}}</th>
              <th class="factorNumCell">{{factorNumtoString[1]}}</th>
              <th class="factorNumCell">{{factorNumtoString[2]}}</th>
              <th class="factorNumCell">{{factorNumtoString[3]}}</th>
              <th class="factorNumCell">{{factorNumtoString[4]}}</th>
              <th class="factorNumCell">{{factorNumtoString[5]}}</th>
              <th class="factorNumCell">{{factorNumtoString[6]}}</th>
              <th class="factorNumCell">{{factorNumtoString[7]}}</th>
              <th class="factorNumCell">{{factorNumtoString[8]}}</th>
              <th class="factorNumCell">{{factorNumtoString[9]}}</th>
              <th class="factorNumCell">{{factorNumtoString[10]}}</th>
              <th class="factorNumCell">{{factorNumtoString[11]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[0]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[1]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[2]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[3]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[4]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[5]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[6]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[7]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[8]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[9]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[10]}}</th>
              <th class="factorNumCell">{{inbreedFactorNumtoString[11]}}</th>
              <th v-if="dispCategory % 2 === 0" :class="styleThoeryClass"></th>
              <th v-else >{{categoryNumtoString}}</th>
            </tr>
          </tbody>

          <tbody v-if="$vuetify.breakpoint.smAndDown">
            <tr>
              <td width="1%"></td>
              <td width="13%"></td>
              <td class="f01">短</td>
              <td class="f02">速</td>
              <td class="f03">底</td>
              <td class="f04">長</td>
              <td class="f05">適</td>
              <td class="f06">丈</td>
              <td class="f07">早</td>
              <td class="f08">晩</td>
              <td class="f09">堅</td>
              <td class="f10">難</td>
              <td class="f11">走</td>
              <td class="f12">中</td>
              <th v-if="dispCategory % 2 === 0" class="f00_theory">理論</th>
              <th v-else class="f00_theory">子系統</th>
            </tr>
            <tr>
              <td colspan="14" class="f00_nitro_header"></td>
              <td v-if="dispCategory % 2 === 0" rowspan="2" :class="styleThoeryClass" align="center"></td>
              <td v-else rowspan="2" align="center">{{categoryNumtoString}}</td>

            </tr>
            <tr>
              <td class="f00_nitro" colspan="2">ニトロ</td>
              <td class="factorNumCell">{{factorNumtoString[0]}}</td>
              <td class="factorNumCell">{{factorNumtoString[1]}}</td>
              <td class="factorNumCell">{{factorNumtoString[2]}}</td>
              <td class="factorNumCell">{{factorNumtoString[3]}}</td>
              <td class="factorNumCell">{{factorNumtoString[4]}}</td>
              <td class="factorNumCell">{{factorNumtoString[5]}}</td>
              <td class="factorNumCell">{{factorNumtoString[6]}}</td>
              <td class="factorNumCell">{{factorNumtoString[7]}}</td>
              <td class="factorNumCell">{{factorNumtoString[8]}}</td>
              <td class="factorNumCell">{{factorNumtoString[9]}}</td>
              <td class="factorNumCell">{{factorNumtoString[10]}}</td>
              <td class="factorNumCell">{{factorNumtoString[11]}}</td>
            </tr>
            <tr>
              <td colspan="14" class="f00_inbreed_header"></td>
              <td v-if="dispCategory % 2 === 0" rowspan="2" @click="initializer()" style="background-color: #aa0000" align="center"><v-icon size="large" color="white">mdi-reload</v-icon></td>
              <td
                v-else
                rowspan="2"
                :style="combinationCellStyle"
                align="center"
                @click="handleCombinationCellClick"
              ><v-icon size="large" color="white">mdi-horse-variant</v-icon></td>
            </tr>
            <tr>
              <td colspan="2" class="f00_inbreed">クロス</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[0]}}</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[1]}}</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[2]}}</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[3]}}</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[4]}}</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[5]}}</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[6]}}</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[7]}}</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[8]}}</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[9]}}</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[10]}}</td>
              <td class="factorNumCell">{{inbreedFactorNumtoString[11]}}</td>
            </tr>            <!-- ここから下がいらない -->
          </tbody>
        </table>
      </header>

      <!-- 配合保存ダイアログ -->
      <combination-dialog
        v-model="combinationDialogVisible"
        @restore="onCombinationRestore"
      ></combination-dialog>


      <main>
        <v-container fluid>
          <v-spacer class="my-1 px-0 mx-0 my-0" />
          <v-row class="mx-1" align-content="center">
            <!-- <v-spacer class="my-1 px-0 mx-0 my-0" /> -->
            <!-- xsを設定できないので↓のようなカンジで -->
            <v-col sm="12" md="6" lg="6" xl="6" cols="12">
              <v-card elevation="3" align-content="center" class="custom-card">
                <v-row no-gutters>
                  <v-col cols="3">
                    <v-card-title
                      v-if="this.windowSize >= 770"
                      style="font-size: 16px; font-weight: bolder d-flex justify-center fill-height"
                      class="px-0"
                      outlined
                      >
                      種牡馬検索
                    </v-card-title>
                  </v-col>
                  <v-col mt-0>
                    <v-text-field
                      v-model="this.inputedMemoStallion"
                      @change="memoChangeStallion($event)"
                      v-if="this.windowSize >= 770"
                      label="メモ"
                      dense
                      single-line
                      style="font-size: 10px;"
                    ></v-text-field>
                  </v-col>
                </v-row>
                <table class="table_main">
                  <tbody>
                    <!-- 最適化: rowConfigsは変更されないためv-onceの代わりにキーを使用 -->
                    <tr
                      is="pedigree-row"
                      v-for="config in rowConfigs"
                      :key="config.index"
                      :config="config"
                      :disp-color="dispColor"
                      :selected="selected"
                      :horse-data-lists="horseDataLists"
                      :on-change="onChange"
                      :disp-category="dispCategory"
                      :category="category"
                      :inputed="inputed"
                      :memo-change="memoChange"
                      :get-css="getCss"
                      :index-generation-assignments="INDEX_GENERATION_ASSIGNMENTS"
                      :style-parent-line-classes="styleParentLineClasses"
                      :parent-lines="parentLines"
                      :style-inbreed-button-classes="styleInbreedButtonClasses"
                      :is-inbreed-button-clicked="isInbreedButtonClicked"
                      :reload="reload"
                      :handle-inbreed-button-click="handleInbreedButtonClick"
                      :size="size"
                      :style-factor-classes="styleFactorClasses"
                      :factor-name="factorName"
                      :on-manual-factor-update="applyManualFactors"
                      :disp-button-name="dispButtonName"
                      :on-toggle-category="handleClick"
                    ></tr>
                  </tbody>
                </table>
                <v-spacer class="my-1 px-0 mx-0 my-0" />
              </v-card>
            </v-col>
            <!-- xsを設定できないので↓のようなカンジで -->
            <v-col sm="12" md="6" lg="6" xl="6" cols="12">
              <v-card elevation="3" align-content="center" class="custom-card">
                <v-row no-gutters>
                  <v-col cols="4" class="d-flex align-center fill-height">
                    <v-card-title
                      v-if="this.windowSize >= 770"
                      style="font-size: 16px; font-weight: bolder d-flex justify-center fill-height"
                      class="px-0"
                      outlined
                    >
                      繫殖牝馬検索
                    </v-card-title>
                  </v-col>
                  <v-col mt-0>
                    <v-text-field
                      v-model="this.inputedMemoBroodmare"
                      @change="memoChangeBroodmare($event)"
                      v-if="this.windowSize >= 770"
                      label="メモ"
                      dense
                      single-line
                      style="font-size: 10px;"
                    ></v-text-field>
                  </v-col>
                </v-row>
                <!-- 繫殖牝馬側 -->
                <table class="table_main">
                  <tbody>
                    <!-- 最適化: rowConfigsは変更されないためv-onceの代わりにキーを使用 -->
                    <tr
                      is="pedigree-row"
                      v-for="config in rowConfigsBloodmare"
                      :key="config.index"
                      :config="config"
                      :disp-color="dispColor"
                      :selected="selected"
                      :horse-data-lists="horseDataLists"
                      :on-change="onChange"
                      :disp-category="dispCategory"
                      :category="category"
                      :inputed="inputed"
                      :memo-change="memoChange"
                      :get-css="getCss"
                      :index-generation-assignments="INDEX_GENERATION_ASSIGNMENTS"
                      :style-parent-line-classes="styleParentLineClasses"
                      :parent-lines="parentLines"
                      :style-inbreed-button-classes="styleInbreedButtonClasses"
                      :is-inbreed-button-clicked="isInbreedButtonClicked"
                      :reload="reload"
                      :handle-inbreed-button-click="handleInbreedButtonClick"
                      :size="size"
                      :style-factor-classes="styleFactorClasses"
                      :factor-name="factorName"
                      :on-manual-factor-update="applyManualFactors"
                      :disp-button-name="dispButtonName"
                      :on-toggle-category="handleClick"
                    ></tr>
                  </tbody>
                </table>
                <!-- <v-spacer class="my-1 px-0 mx-0 my-0" /> -->
              </v-card>
            </v-col>
          </v-row>
        </v-container>
      </main>
    </v-app>
  </body>

  <script src="./vue/vue.min.js"></script>
  <script src="./vue/CombinationDialog.js"></script>
  <script src="./vue/vuetify.js"></script>
  <script src="./vue/factor-dialog.js"></script>

  <!-- index.html 内、</table> の前あたり etc. -->
  <script type="text/x-template" id="pedigree-row-template">
    <tr>
      <template v-for="cell in config.headCells" :key="cell.key">
        <td
          :class="cell.class"
          :rowspan="cell.rowspan"
          :colspan="cell.colspan"
          :width="cell.width"
          :align="cell.align"
        >{{ cell.text }}</td>
      </template>

      <td :class="config.autoClass" :colspan="config.autoColspan">
        <common-autocomplete
          :class="rowDispColor"
          :index="config.index"
          :selected="selected"
          :horses="horseDataLists"
          :on-change="onChange"
          :disp-category="dispCategory"
          :category="category"
          :inputed="inputed"
          :memo-change="memoChange"
        />
      </td>

      <td :class="[getCss(config.index), 'styleFactorClassMain']">
        {{ generationLabel }}
      </td>

      <td :class="parentLineClass">
        <span class="styleParentLineText">
          {{ config.showParentLine ? parentLineText : '' }}
        </span>
      </td>

      <td :class="inbreedButtonClass">
        <v-btn
          v-if="btnState === -1"
          :key="reload"
          @click="handleInbreedButtonClick(config.index)"
          icon
          v-bind="size"
        ><v-icon>mdi-heart-outline</v-icon></v-btn>
        <v-btn
          v-else-if="btnState === 1"
          :key="reload"
          @click="handleInbreedButtonClick(config.index)"
          icon
          color="pink"
          v-bind="size"
        ><v-icon>mdi-heart</v-icon></v-btn>
        <v-btn
          v-else
          :key="reload"
          icon
          color="pink"
          disabled
          v-bind="size"
        ><v-icon>mdi-heart</v-icon></v-btn>
      </td>

      <template v-if="rowIndex === 16">
        <td
          colspan="3"
          :class="(styleFactorClasses[rowIndex] && styleFactorClasses[rowIndex][0]) || factorClasses[0]"
        >
          <v-btn v-if="$vuetify.breakpoint.mdAndUp" variant="outlined" @click="handleToggleCategory">{{ dispButtonName || '' }}</v-btn>
          <v-btn v-if="$vuetify.breakpoint.smAndDown" variant="outlined" x-small @click="handleToggleCategory">{{ dispButtonName || '' }}</v-btn>
        </td>
      </template>
      <template v-else>
        <td
          :class="factorClasses[0]"
          :colspan="shouldCollapseFactors ? 3 : null"
        >
          <template v-if="shouldCollapseFactors">
            <v-btn v-if="$vuetify.breakpoint.mdAndUp" variant="outlined" block @click.stop.prevent="openFactorDialog">因子</v-btn>
            <v-btn v-if="$vuetify.breakpoint.smAndDown" variant="outlined" x-small block @click.stop.prevent="openFactorDialog">因子</v-btn>
          </template>
          <template v-else>
            <v-btn v-if="shouldShowFirstFactorButton" class="manual-factor-trigger" @click.stop.prevent="openFactorDialog">因</v-btn>
            <template v-else>
              {{ factorTexts[0] }}
            </template>
          </template>

          <factor-dialog
            v-if="isStarSelection"
            :visible.sync="factorDialogVisible"
            :selected-horse-name="selectedHorseName"
            :current-factors="extractCurrentManualFactors()"
            @confirm="handleFactorConfirm"
          ></factor-dialog>
        </td>
        <template v-if="!shouldCollapseFactors">
          <td 
            :class="factorClasses[1]"
            :style="isStarSelection ? 'cursor: pointer' : ''"
            @click.stop.prevent="isStarSelection ? openFactorDialog() : null"
          >
            {{ factorTexts[1] }}
          </td>
          <td 
            :class="factorClasses[2]"
            :style="isStarSelection ? 'cursor: pointer' : ''"
            @click.stop.prevent="isStarSelection ? openFactorDialog() : null"
          >
            {{ factorTexts[2] }}
          </td>
        </template>
      </template>
    </tr>
  </script>

  <script>
    //loadingAnimation
    window.onload = () => {
      const loader = document.getElementById("loader");
      loader.classList.add("loaded");
    };

    // service workerの登録関係
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("./service-worker.js")
        .then(function (registration) {
          console.log(
            "ServiceWorker registration successful with scope: ",
            registration.scope
          );
        })
        .catch(function (err) {
          console.log("ServiceWorker registration failed: ", err);
        });
    }

    var ua = navigator.userAgent.toLowerCase();
    var isiOS = ua.indexOf("iphone") > -1 || ua.indexOf("ipad") > -1;
    if (isiOS) {
      var viewport = document.querySelector('meta[name="viewport"]');
      if (viewport) {
        var viewportContent = viewport.getAttribute("content");
        viewport.setAttribute(
          "content",
          viewportContent + ", user-scalable=no"
        );
      }
    }

    const INDEX_GENERATION_ASSIGNMENTS = [
      '①',' ②',' ③',' ③',' ④',' ④',' ④',' ④',' ⑤',' ⑤',' ⑤',' ⑤',' ⑤',' ⑤',' ⑤',' ⑤',
      '①',' ②',' ③',' ③',' ④',' ④',' ④',' ④',' ⑤',' ⑤',' ⑤',' ⑤',' ⑤',' ⑤',' ⑤',' ⑤',
    ];
    Object.freeze(INDEX_GENERATION_ASSIGNMENTS);

    // 始祖
    const founder = [
      {key:"Intent" ,value:"インテント系"},
      {key:"エタン" ,value:"エタン系"},
      {key:"Owen Tudor" ,value:"オーエンテューダー系"},
      {key:"Aureole" ,value:"オリオール系"},
      {key:"Khaled" ,value:"カーレッド系"},
      {key:"Clarion" ,value:"クラリオン系"},
      {key:"Grey Sovereign" ,value:"グレイソヴリン系"},
      {key:"Sir Gaylord" ,value:"サーゲイロード系"},
      {key:"Son-in-Law" ,value:"サンインロー系"},
      {key:"Swynford" ,value:"スインフォード系"},
      {key:"ゼダーン" ,value:"ゼダーン系"},
      {key:"St.Simon" ,value:"セントサイモン系"},
      {key:"Sovereign Path" ,value:"ソヴリンパス系"},
      {key:"ダンテ" ,value:"ダンテ系"},
      {key:"Teddy" ,value:"テディ系"},
      {key:"Tourbillon" ,value:"トウルビヨン系"},
      {key:"Tom Fool" ,value:"トムフール系"},
      {key:"Nasrullah" ,value:"ナスルーラ系"},
      {key:"Nearctic" ,value:"ニアークティック系"},
      {key:"ネアルコ" ,value:"ネアルコ系"},
      {key:"ネイティヴダンサー" ,value:"ネイティヴダンサー系"},
      {key:"Never Say Die" ,value:"ネヴァーセイダイ系"},
      {key:"Never Bend" ,value:"ネヴァーベンド系"},
      {key:"ノーザンダンサー" ,value:"ノーザンダンサー系"},
      {key:"ハイペリオン" ,value:"ハイペリオン系"},
      {key:"ハビタット" ,value:"ハビタット系"},
      {key:"Fine Top" ,value:"ファイントップ系"},
      {key:"Phalaris" ,value:"ファラリス系"},
      {key:"Pharis" ,value:"ファリス系"},
      {key:"Pharos" ,value:"ファロス系"},
      {key:"Fairway" ,value:"フェアウェイ系"},
      {key:"Fair Trial" ,value:"フェアトライアル系"},
      {key:"フォルティノ" ,value:"フォルティノ系"},
      {key:"Brantome" ,value:"ブラントーム系"},
      {key:"Blandford" ,value:"ブランドフォード系"},
      {key:"Princequillo" ,value:"プリンスキロ系"},
      {key:"Prince Bio" ,value:"プリンスビオ系"},
      {key:"Princely Gift" ,value:"プリンスリーギフト系"},
      {key:"Prince Rose" ,value:"プリンスローズ系"},
      {key:"Blenheim" ,value:"ブレニム系"},
      {key:"ヘイルトゥリーズン" ,value:"ヘイルトゥリーズン系"},
      {key:"ボールドルーラー" ,value:"ボールドルーラー系"},
      {key:"Bois Roussel" ,value:"ボワルセル系"},
      {key:"My Babu" ,value:"マイバブー系"},
      {key:"Man o'War" ,value:"マンノウォー系"},
      {key:"Mossborough" ,value:"モスボロー系"},
      {key:"Ribot" ,value:"リボー系"},
      {key:"Raise a Native" ,value:"レイズアネイティヴ系"},
      {key:"Red God" ,value:"レッドゴッド系"},
      {key:"Relic" ,value:"レリック系"},
      {key:"Royal Charger" ,value:"ロイヤルチャージャー系"},
      {key:"Rockefella" ,value:"ロックフェラ系"},
      {key:"ワイルドリスク" ,value:"ワイルドリスク系"},
    ]
    const factorMap = new Map();
    const manualFactorOptions = ["短", "速", "底", "長", "堅", "難"];
    const MANUAL_INBREED_STORAGE_KEY = "dabimasManualInbreed";

    Vue.component('pedigree-row', {
      template: '#pedigree-row-template',
      props: {
        config: { type: Object, required: true },
        dispColor: Array,
        selected: Object,
        horseDataLists: Array,
        onChange: Function,
        dispCategory: Array,
        category: Array,
        inputed: Array,
        memoChange: Function,
        getCss: Function,
        indexGenerationAssignments: Array,
        styleParentLineClasses: Array,
        parentLines: Array,
        styleInbreedButtonClasses: Array,
        isInbreedButtonClicked: Array,
        reload: Number,
        handleInbreedButtonClick: Function,
        size: Object,
        styleFactorClasses: Array,
        factorName: Array,
        onManualFactorUpdate: Function,
        dispButtonName: String,
        onToggleCategory: Function,
      },
      data() {
        return {
          factorDialogVisible: false,
        };
      },
      computed: {
        rowIndex() {
          const value =
            this.config && typeof this.config.index !== "undefined"
              ? this.config.index
              : 0;
          const index = Number(value);
          return Number.isFinite(index) ? index : 0;
        },
        btnState() {
          const states = this.isInbreedButtonClicked || [];
          const value = states[this.rowIndex];
          return typeof value === "number" ? value : 0;
        },
        rowDispColor() {
          const colors = this.dispColor || [];
          return colors[this.rowIndex] || "";
        },
        parentLineClass() {
          const classes = this.styleParentLineClasses || [];
          return classes[this.rowIndex] || "";
        },
        parentLineText() {
          const lines = this.parentLines || [];
          return lines[this.rowIndex] || "";
        },
        inbreedButtonClass() {
          const classes = this.styleInbreedButtonClasses || [];
          const current = classes[this.rowIndex];
          if (current && current.trim() !== "") {
            return current;
          }
          return this.defaultInbreedButtonClass;
        },
        factorClasses() {
          const classes =
            (this.styleFactorClasses && this.styleFactorClasses[this.rowIndex]) ||
            [];
          const fallbackClass = this.defaultFactorClass;
          return [
            classes[0] && classes[0] !== "00" ? classes[0] : fallbackClass,
            classes[1] && classes[1] !== "00" ? classes[1] : fallbackClass,
            classes[2] && classes[2] !== "00" ? classes[2] : fallbackClass,
          ];
        },
        factorTexts() {
          const names =
            (this.factorName && this.factorName[this.rowIndex]) || [];
          return [
            names[0] || "",
            names[1] || "",
            names[2] || "",
          ];
        },
        selectedHorseName() {
          const selectedList = Array.isArray(this.selected)
            ? this.selected
            : [];
          const item = selectedList[this.rowIndex];
          const name = typeof item?.name === "string" ? item.name : "";
          return name.trim();
        },
        isStarSelection() {
          const name = this.selectedHorseName;
          return !!name && name.startsWith("★");
        },
        hasConfiguredFactorClasses() {
          if (
            !Array.isArray(this.styleFactorClasses) ||
            !Array.isArray(this.styleFactorClasses[this.rowIndex])
          ) {
            return false;
          }
          return this.styleFactorClasses[this.rowIndex].some((value) =>
            /^f\d{2}/.test((value || "").trim())
          );
        },
        shouldCollapseFactors() {
          return this.isStarSelection && !this.hasConfiguredFactorClasses;
        },
        shouldShowFirstFactorButton() {
          return this.isStarSelection && this.hasConfiguredFactorClasses;
        },
        defaultFactorClass() {
          if (typeof this.getCss !== "function") {
            return "styleFactorClassMain";
          }
          const baseClass = this.getCss(this.rowIndex) || "";
          return `${baseClass} styleFactorClassMain`.trim();
        },
        defaultInbreedButtonClass() {
          if (typeof this.getCss !== "function") {
            return "styleInbreedButton";
          }
          const baseClass = this.getCss(this.rowIndex) || "";
          return `${baseClass} styleInbreedButton`.trim();
        },
        generationLabel() {
          const assignments = this.indexGenerationAssignments || [];
          return assignments[this.rowIndex] || "";
        },
      },
      methods: {
        openFactorDialog() {
          if (!this.isStarSelection) {
            return;
          }
          this.factorDialogVisible = true;
        },
        handleFactorConfirm(selectedFactors) {
          if (typeof this.onManualFactorUpdate === "function") {
            this.onManualFactorUpdate(
              this.rowIndex,
              selectedFactors
            );
          }
        },
        handleToggleCategory() {
          if (typeof this.onToggleCategory === "function") {
            this.onToggleCategory();
          }
        },
        extractCurrentManualFactors() {
          return [this.factorTexts[1], this.factorTexts[2]]
            .map((value) => (typeof value === "string" ? value.trim() : ""))
            .filter((value) => value && ['短', '速', '底', '長', '堅', '難'].includes(value));
        },
      },
    });

    // カスタムコンポーネント定義（コンボボックス）
    Vue.component("common-autocomplete", {
      template: `
      <v-autocomplete
        v-if="dispCategory%2 === 0"
        :value="selected[index]"
        :items="lists"
        :item-text="horse => [horse.nature ? '[' + horse.nature.charAt(0) + ']' : '', horse.name, horse.subName].filter(Boolean).join('')"
        solo
        dense
        :placeholder="placeholderText"
        no-data-text="該当するデータはありません"
        @input="onChange(sex, index - (sex * 16), $event)"
        return-object
      >
        <template v-slot:item="data">
          <template >
            <v-list-item-content>
              <v-list-item-title v-html="getHorse(data.item)"></v-list-item-title>
            </v-list-item-content>
          </template>
        </template>
      </v-autocomplete>
      <v-row no-gutters v-else>
        <v-col :style="getWidth(index,0)">
          <v-text-field
            :value="category[index]"
            solo
            readonly
          ></v-text-field>
        </v-col>
        <v-col :style="getWidth(index,1)">
          <v-text-field
            placeholder="メモ入力"
            :value="inputed[index]"
            @change="memoChange(index, $event)"
            solo
          ></v-text-field>
        </v-col>
      </v-row>
    </div>    `,
      props: {
        index: {
          type: Number,
          required: true,
        },
        inputed: {
          type: Array,
          required: true,
        },
        selected: {
          type: Array,
          required: true,
        },
        horses: {
          type: Array,
          required: true,
        },
        onChange: {
          type: Function,
          required: true,
        },
        memoChange: {
          type: Function,
          required: true,
        },
        dispCategory: {
          type: Number,
          required: true,
        },
        category: {
          type: Array,
          required: true,
        },
      },
      methods: {
        getWidth(index, type) {
          let coefficient = 0;
          switch (index % 16) {
            case 0:
              coefficient = 0;
              break;
            case 1:
              coefficient = 1;
              break;
            case 2:
            case 3:
              coefficient = 2;
              break;
            case 4:
            case 5:
            case 6:
            case 7:
              coefficient = 3;
              break;
            default:
              coefficient = 4;
              break;
          }

          // コンテンツ（デバイス）の高さで幅を変えるロジック
          const width = window.innerHeight >= 960 ? 20 : 12;

          const adjustment = coefficient * width;
          if (type === 0) {
            // 左側カラム: (100% - adjustment) / 2
            return { maxWidth: `calc(100% - calc((100% + ${adjustment}px) * 0.35 ))` };
          } else {
            // 右側カラム: 残りの幅
            return { maxWidth: `calc((100% + ${adjustment}px) * 0.35 )` };
          }
        },
        getHorse(horse) {
          if (!horse?.disabled) {
            const natureTag = horse.nature ? `[${horse.nature.charAt(0)}]` : '';
            return natureTag + horse.name + horse.subName + this.getFactor(horse.factors);
          }
        },
        getFactor(factors) {
          let retFactor = "";
          if (factors[2] != "") {
            retFactor = "(";
            for (const factor in factors) {
              if (factor) {
                retFactor += factors[factor];
              }
            }
            retFactor += ")";
          }
          return retFactor;
        },
      },
      computed: {
        computedStyle(newValue) {
          return {
            maxWidth: `calc(50% + ${this.getOffset(newValue.index)}px)`
          };
        },
        placeholderText(newValue) {
          if (
            Math.floor(newValue.index / 16) === 1 &&
            newValue.index % 16 === 0
          ) {
            return "繫殖牝馬を選んでください";
          } else {
            switch (newValue.index % 16) {
              case 3:
              case 5:
              case 7:
              case 9:
              case 11:
              case 13:
              case 15:
                return "種牡馬 or 繫殖牝馬を選んでください";
                break;
              default:
                return "種牡馬を選んでください";
                break;
            }
          }
        },
        sex(newValue) {
          // index>=16が牝馬
          return Math.floor(newValue.index / 16);
        },
        // 馬のリスト
        lists(newValue) {
          let retList;

          if (this.sex === 1 && this.index % 16 === 0) {
            //繫殖牝馬をセット
            retList = this.horses[2];
          } else {
            switch (this.index % 16) {
              case 3:
              case 5:
              case 7:
              case 9:
              case 11:
              case 13:
              case 15:
                // 種牡馬と繫殖牝馬をセット
                retList = this.horses[0];
                break;
              default:
                // 種牡馬のみをセット
                retList = this.horses[1];
                break;
            }
          }
          return retList;
        },
      },
    });

    // パフォーマンス最適化設定
    Vue.config.performance = true;
    Vue.config.productionTip = false;

    new Vue({
      el: "#app",
      vuetify: new Vuetify(),

      data() {
        return {
          rowConfigs: [
            { index: 0, autoClass: 'horse_all AliceBlue', autoColspan: 5, headCells: [], showParentLine: false },
            { index: 1, autoClass: 'omoshiro_0', autoColspan: 4, showParentLine: true,
              headCells: [{ key: 'r1c1', text: '父', class: 'father_0', align: 'center', width: 15 }] },
            { index: 2, autoClass: 'horse_0', autoColspan: 3, showParentLine: true,
              headCells: [
                { key: 'r2c1', text: '', class: 'father_1', rowspan: 7, width: 15, align: 'center' },
                { key: 'r2c2', text: '父', class: 'father_0', width: 15 },
              ] },
            { index: 4, autoClass: 'horse_0', autoColspan: 2, showParentLine: false,
              headCells: [
                { key: 'r4c1', text: '', class: 'father_1', rowspan: 3, width: 15, align: 'center' },
                { key: 'r4c2', text: '父', class: 'father_0', width: 15 },
              ] },
            { index: 8, autoClass: 'horse_0', autoColspan: 1, showParentLine: false,
              headCells: [
                { key: 'r8c1', text: '', class: 'father_1', width: 15, align: 'center' },
                { key: 'r8c2', text: '父', class: 'father', width: 15 },
              ] },
            { index: 9, autoClass: 'migoto_0', autoColspan: 1, showParentLine: true,
              headCells: [
                { key: 'r9c1', text: '母', class: 'mother' },
                { key: 'r9c2', text: '父', class: 'father' },
              ] },
            { index: 5, autoClass: 'omoshiro_0', autoColspan: 2, showParentLine: true,
              headCells: [
                { key: 'r5c1', text: '母', class: 'mother_0' },
                { key: 'r5c2', text: '父', class: 'father_0' },
              ] },
            { index: 10, autoClass: 'horse_0', autoColspan: 1, showParentLine: false,
              headCells: [
                { key: 'r10c1', text: '', class: 'mother_1', rowspan: 2 },
                { key: 'r10c2', text: '', class: 'father_1' },
                { key: 'r10c3', text: '父', class: 'father' },
              ] },
            { index: 11, autoClass: 'migoto_0', autoColspan: 1, showParentLine: true,
              headCells: [
                { key: 'r11c1', text: '母', class: 'mother' },
                { key: 'r11c2', text: '父', class: 'father' },
              ] },
            { index: 3, autoClass: 'omoshiro_0', autoColspan: 3, showParentLine: true,
              headCells: [
                { key: 'r3c1', text: '母', class: 'mother_0' },
                { key: 'r3c2', text: '父', class: 'father_0' },
              ] },
            { index: 6, autoClass: 'horse_0', autoColspan: 2, showParentLine: false,
              headCells: [
                { key: 'r6c1', text: '', class: 'mother_1', rowspan: 6 },
                { key: 'r6c2', text: '', class: 'father_1', rowspan: 3 },
                { key: 'r6c3', text: '父', class: 'father_0' },
              ] },
            { index: 12, autoClass: 'horse_0', autoColspan: 1, showParentLine: false,
              headCells: [
                { key: 'r12c1', text: '', class: 'father_1' },
                { key: 'r12c2', text: '父', class: 'father' },
              ] },
            { index: 13, autoClass: 'migoto_0', autoColspan: 1, showParentLine: true,
              headCells: [
                { key: 'r13c1', text: '母', class: 'mother' },
                { key: 'r13c2', text: '父', class: 'father' },
              ] },
            { index: 7, autoClass: 'omoshiro_0', autoColspan: 2, showParentLine: true,
              headCells: [
                { key: 'r7c1', text: '母', class: 'mother_0' },
                { key: 'r7c2', text: '父', class: 'father_0' },
              ] },
            { index: 14, autoClass: 'horse_0', autoColspan: 1, showParentLine: false,
              headCells: [
                { key: 'r14c1', text: '', class: 'mother_1', rowspan: 2 },
                { key: 'r14c2', text: '', class: 'father_1' },
                { key: 'r14c3', text: '父', class: 'father' },
              ] },
            { index: 15, autoClass: 'migoto_0', autoColspan: 1, showParentLine: true,
              headCells: [
                { key: 'r15c1', text: '母', class: 'mother' },
                { key: 'r15c2', text: '父', class: 'father' },
              ] },
          ],
          rowConfigsBloodmare: [
            { index: 0+16, autoClass: 'horse_all SalmonPink', autoColspan: 5, headCells: [], showParentLine: false },
            { index: 1+16, autoClass: 'horse_all Broodmare', autoColspan: 4, showParentLine: true,
              headCells: [{ key: 'r1c1', text: '父', class: 'father_0', align: 'center', width: 15 }] },
            { index: 2+16, autoClass: 'horse_0', autoColspan: 3, showParentLine: true,
              headCells: [
                { key: 'r2c1', text: '', class: 'father_1', rowspan: 7, width: 15, align: 'center' },
                { key: 'r2c2', text: '父', class: 'father_0', width: 15 },
              ] },
            { index: 4+16, autoClass: 'horse_0', autoColspan: 2, showParentLine: false,
              headCells: [
                { key: 'r4c1', text: '', class: 'father_1', rowspan: 3, width: 15, align: 'center' },
                { key: 'r4c2', text: '父', class: 'father_0', width: 15 },
              ] },
            { index: 8+16, autoClass: 'horse_0', autoColspan: 1, showParentLine: false,
              headCells: [
                { key: 'r8c1', text: '', class: 'father_1', width: 15, align: 'center' },
                { key: 'r8c2', text: '父', class: 'father', width: 15 },
              ] },
            { index: 9+16, autoClass: 'horse_0', autoColspan: 1, showParentLine: true,
              headCells: [
                { key: 'r9c1', text: '母', class: 'mother' },
                { key: 'r9c2', text: '父', class: 'father' },
              ] },
            { index: 5+16, autoClass: 'horse_all Broodmare', autoColspan: 2, showParentLine: true,
              headCells: [
                { key: 'r5c1', text: '母', class: 'mother_0' },
                { key: 'r5c2', text: '父', class: 'father_0' },
              ] },
            { index: 10+16, autoClass: 'horse_0', autoColspan: 1, showParentLine: false,
              headCells: [
                { key: 'r10c1', text: '', class: 'mother_1', rowspan: 2 },
                { key: 'r10c2', text: '', class: 'father_1' },
                { key: 'r10c3', text: '父', class: 'father' },
              ] },
            { index: 11+16, autoClass: 'horse_0', autoColspan: 1, showParentLine: true,
              headCells: [
                { key: 'r11c1', text: '母', class: 'mother' },
                { key: 'r11c2', text: '父', class: 'father' },
              ] },
            { index: 3+16, autoClass: 'horse_all Broodmare', autoColspan: 3, showParentLine: true,
              headCells: [
                { key: 'r3c1', text: '母', class: 'mother_0' },
                { key: 'r3c2', text: '父', class: 'father_0' },
              ] },
            { index: 6+16, autoClass: 'horse_0', autoColspan: 2, showParentLine: false,
              headCells: [
                { key: 'r6c1', text: '', class: 'mother_1', rowspan: 6 },
                { key: 'r6c2', text: '', class: 'father_1', rowspan: 3 },
                { key: 'r6c3', text: '父', class: 'father_0' },
              ] },
            { index: 12+16, autoClass: 'horse_0', autoColspan: 1, showParentLine: false,
              headCells: [
                { key: 'r12c1', text: '', class: 'father_1' },
                { key: 'r12c2', text: '父', class: 'father' },
              ] },
            { index: 13+16, autoClass: 'horse_0', autoColspan: 1, showParentLine: true,
              headCells: [
                { key: 'r13c1', text: '母', class: 'mother' },
                { key: 'r13c2', text: '父', class: 'father' },
              ] },
            { index: 7+16, autoClass: 'horse_all Broodmare', autoColspan: 2, showParentLine: true,
              headCells: [
                { key: 'r7c1', text: '母', class: 'mother_0' },
                { key: 'r7c2', text: '父', class: 'father_0' },
              ] },
            { index: 14+16, autoClass: 'horse_0', autoColspan: 1, showParentLine: false,
              headCells: [
                { key: 'r14c1', text: '', class: 'mother_1', rowspan: 2 },
                { key: 'r14c2', text: '', class: 'father_1' },
                { key: 'r14c3', text: '父', class: 'father' },
              ] },
            { index: 15+16, autoClass: 'horse_0', autoColspan: 1, showParentLine: true,
              headCells: [
                { key: 'r15c1', text: '母', class: 'mother' },
                { key: 'r15c2', text: '父', class: 'father' },
              ] },
          ],
          INDEX_GENERATION_ASSIGNMENTS,
          windowSize: 0,
          // メモの
          inputed: Array.from(new Array(32).fill(null)),
          // メモ種牡馬
          inputedMemoStallion: null,
          // メモ繫殖牝馬
          inputedMemoBroodmare: null,
          dispColor: Array.from(new Array(32).fill("")),
          horseDataLists: [[], [], []],
          factorCd: Array.from(new Array(32), () => new Array(3).fill("00")),
          selected: Array.from(new Array(32).fill(null)),
          // 親系統
          parentLines: Array.from(new Array(32).fill("")),
          // 子系統
          category: Array.from(new Array(32).fill(null)),
          stallions: [],
          stallionsBase: [],
          broodmares: [],
          broodmaresBase: [],
          theoryOmoshiro: [1, 3, 5, 7],
          theoryMigoto: [9, 11, 13, 15],
          // 全兄弟
          brosData:[],
          // インブリードボタン押下フラグを一次元配列で定義（-1：未クリック　1：クリック　0:使用不可）
          isInbreedButtonClicked: Array.from(new Array(32).fill(0)),
          // styleInbreedButtonClasses（インブリードさせるボタン定義）を一次元配列で定義
          styleInbreedButtonClasses: Array.from(new Array(32).fill("")),
          // styleFactorClassesを二次元配列で定義
          styleFactorClasses: Array.from(new Array(32), () =>
            new Array(3).fill("00")
          ),
          // factorNameを二次元配列で定義
          factorName: Array.from(new Array(32), () => new Array(3).fill("")),

          // styleParentLineClassesを一次元配列で定義
          styleParentLineClasses: Array.from(new Array(32).fill("")),
          // 合計因子数表示（走中因子も）
          factorNumtoString: Array.from(new Array(12).fill("00")),
          // インブリードされた因子数表示（走長因子も）
          inbreedFactorNumtoString: Array.from(new Array(12).fill("00")),
          // 子系統数
          categoryNumtoString: "00",

          // 配合理論
          styleThoeryClass: "",

          // リストで選択された性別
          selectedSex: null,

          // 子系統を表示させるフラグ
          dispCategory: 0,
          // ボタン表示名
          dispButtonName: '子系統',

          // インブリードされているところを格納する変数
          inbreedList: Array.from(new Array(32).fill(null)),
          // 同名・全兄妹の組み合わせ一覧
          sameNameGroups: {
            byIndex: [[], []],
            indexes: [],
            special: {
              sameName: {
                byGroup: [],
                byIndex: [],
              },
            },
          },
          sameNameSpecialChecks: [],
          sameNameSpecialChecksByIndex: Array.from(new Array(32).fill(false)),
          reload: 0,
          size: {},
          combinationDialogVisible: false,
          inbreedLogTimer: null,
          deferInbreedCount: false,
          deferredInbreedCountRequested: false,
          // インブリード例外ルール
          inbreedExceptions: []
        };
      },
      computed: {
        // 頻繁に使用される計算をキャッシュ
        rowConfigsOptimized() {
          // rowConfigsは変更されないのでフリーズ
          return this.rowConfigs;
        },
        // カテゴリー番号の文字列表現（キャッシュ）
        categoryNumComputed() {
          const allSet = this.selected.every((e) => e) ? 0 : -1;
          return (new Set(this.category).size + allSet).toString();
        },
        // すべての馬がセットされているか（キャッシュ）
        allHorsesSet() {
          return this.selected.every((e) => e);
        },
        combinationCellStyle() {
          return this.allHorsesSet
            ? {
                background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
                cursor: "pointer",
              }
            : {
                background: "#bdbdbd",
                cursor: "not-allowed",
              };
        }
      },
      watch: {
        dispCategory: function(value) {
          this.dispButtonName = value%2 === 0 ? '子系統' : '因　子';
        },
      },

      //async created () {
      created() {
        const btnSize = {
          xs: "x-small",
          md: "small",
          sm: "small",
          lg: "small",
          xl: "small",
        };
        const size = btnSize[this.$vuetify.breakpoint.name];
        this.size = { [size]: true };
      },

      mounted: function () {
        try {
          // インブリード例外ルールを読み込む
          this.loadInbreedExceptions()
            .then(() => this.c1())
            .then(() => this.c2())
            .then(() => this.c3());
          // .finally(() => this.c4());
        } catch (error) {
          console.error(error);
        }
      },

      methods: {
        // インブリード例外ルールを読み込む
        loadInbreedExceptions: function () {
          return fetch('./json/inbreed-exceptions.json')
            .then(response => {
              if (!response.ok) {
                console.warn('inbreed-exceptions.json not found, using empty rules');
                return [];
              }
              return response.json();
            })
            .then(data => {
              this.inbreedExceptions = data;
              console.log('Loaded inbreed exceptions:', this.inbreedExceptions);
            })
            .catch(error => {
              console.error('Error loading inbreed-exceptions.json:', error);
              this.inbreedExceptions = [];
            });
        },
        combinationDialog: function () {
          console.log('combinationDialog called');
          this.combinationDialogVisible = true;
          console.log('combinationDialogVisible set to:', this.combinationDialogVisible);
        },
        handleCombinationCellClick: function () {
          if (!this.allHorsesSet) {
            return;
          }
          this.combinationDialog();
        },
        onCombinationRestore: function (configData) {
          // localStorageには既にコンポーネント内で復元済み
          // 画面を再読み込み
          this.restoreInputData();
          
          if (configData.dabimasMemo) {
            const parseArray = JSON.parse(configData.dabimasMemo);
            this.inputed = parseArray;
          }
          if (configData.dabimasMemoStallion) {
            this.inputedMemoStallion = configData.dabimasMemoStallion;
          }
          if (configData.dabimasMemoBroodmare) {
            this.inputedMemoBroodmare = configData.dabimasMemoBroodmare;
          }
        },
        fetchSavedCombinations: function () {
          return new Promise((resolve, reject) => {
            if (!this.combinationDb) {
              this.savedCombinations = [];
              resolve([]);
              return;
            }
            const transaction = this.combinationDb.transaction(
              [COMBINATION_STORE_NAME],
              "readonly"
            );
            transaction.onerror = (event) => {
              reject(event.target.error);
            };
            const store = transaction.objectStore(COMBINATION_STORE_NAME);
            const request = store.getAll();
            request.onsuccess = () => {
              const rows = (request.result || []).sort(
                (a, b) => (b.createdAt || 0) - (a.createdAt || 0)
              );
              this.savedCombinations = rows;
              resolve(rows);
            };
            request.onerror = (event) => {
              reject(event.target.error);
            };
          });
        },
        enforceCombinationLimit: function (maxCount = 10) {
          return new Promise((resolve, reject) => {
            if (!this.combinationDb) {
              resolve();
              return;
            }
            const transaction = this.combinationDb.transaction(
              [COMBINATION_STORE_NAME],
              "readwrite"
            );
            const store = transaction.objectStore(COMBINATION_STORE_NAME);
            transaction.oncomplete = () => resolve();
            transaction.onerror = (event) =>
              reject(event.target.error || new Error("transaction error"));
            const request = store.getAll();
            request.onsuccess = () => {
              const rows = request.result || [];
              if (rows.length <= maxCount) {
                return;
              }
              const sorted = rows
                .slice()
                .sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
              const deleteTargets = sorted.slice(0, rows.length - maxCount);
              deleteTargets.forEach((item) => {
                if (item?.id !== undefined) {
                  store.delete(item.id);
                }
              });
            };
            request.onerror = (event) =>
              reject(event.target.error || new Error("request error"));
          });
        },
        applySavedCombination: async function (record) {
          if (!window.localStorage) {
            return;
          }
          const snapshot = record || {};
          this.setOrRemoveLocalStorage("dabimasFactor", snapshot.factor);
          this.setOrRemoveLocalStorage(
            "dabimasFactorCategory",
            snapshot.factorCategory
          );
          this.setOrRemoveLocalStorage("dabimasMemo", snapshot.memo);
          this.setOrRemoveLocalStorage(
            "dabimasMemoStallion",
            snapshot.memoStallion
          );
          this.setOrRemoveLocalStorage(
            "dabimasMemoBroodmare",
            snapshot.memoBroodmare
          );
          this.setOrRemoveLocalStorage(
            MANUAL_INBREED_STORAGE_KEY,
            snapshot.manualInbreed
          );
          await this.refreshLocalDataFromStorage();
        },
        setOrRemoveLocalStorage: function (key, value) {
          if (value === null || value === undefined) {
            localStorage.removeItem(key);
          } else {
            localStorage.setItem(key, value);
          }
        },
        persistManualInbreedState: function () {
          if (typeof window === "undefined" || !window.localStorage) {
            return;
          }
          const manualIndexes = this.inbreedList
            .map((value, index) => (value?.selfInbreed ? index : null))
            .filter((index) => index !== null);
          if (manualIndexes.length === 0) {
            window.localStorage.removeItem(MANUAL_INBREED_STORAGE_KEY);
            return;
          }
          window.localStorage.setItem(
            MANUAL_INBREED_STORAGE_KEY,
            JSON.stringify(manualIndexes)
          );
        },
        clearManualInbreedForIndex: function (index) {
          if (
            typeof window === "undefined" ||
            !window.localStorage ||
            !Number.isInteger(index)
          ) {
            return;
          }
          const rawIndexes = window.localStorage.getItem(
            MANUAL_INBREED_STORAGE_KEY
          );
          if (!rawIndexes) {
            return;
          }
          let manualIndexes = [];
          try {
            manualIndexes = JSON.parse(rawIndexes) || [];
          } catch (error) {
            console.error(error);
            return;
          }
          if (!Array.isArray(manualIndexes)) {
            return;
          }
          const filtered = manualIndexes
            .map((value) => Number(value))
            .filter(
              (value) => Number.isInteger(value) && value !== Number(index)
            );
          if (filtered.length === 0) {
            window.localStorage.removeItem(MANUAL_INBREED_STORAGE_KEY);
          } else {
            window.localStorage.setItem(
              MANUAL_INBREED_STORAGE_KEY,
              JSON.stringify(filtered)
            );
          }
        },
        restoreManualInbreedState: function () {
          if (typeof window === "undefined" || !window.localStorage) {
            return;
          }
          const rawIndexes = window.localStorage.getItem(
            MANUAL_INBREED_STORAGE_KEY
          );
          if (!rawIndexes) {
            return;
          }
          let manualIndexes = [];
          try {
            manualIndexes = JSON.parse(rawIndexes) || [];
          } catch (error) {
            console.error(error);
            return;
          }
          if (!Array.isArray(manualIndexes)) {
            return;
          }
          let hasUpdates = false;
          manualIndexes.forEach((value) => {
            const index = Number(value);
            if (!Number.isInteger(index) || index < 0 || index >= this.inbreedList.length) {
              return;
            }
            const base = this.selected[index];
            if (!base) {
              return;
            }
            this.$set(this.inbreedList, index, {
              ...base,
              selfInbreed: true,
            });
            this.$set(this.isInbreedButtonClicked, index, 1);
            this.$set(this.dispColor, index, "inbreed");
            hasUpdates = true;
          });
          if (hasUpdates) {
            this.dispInbreedFactorCounts();
          }
        },
        refreshLocalDataFromStorage: async function () {
          if (!window.localStorage) {
            return;
          }
          this.deferInbreedCount = true;
          this.deferredInbreedCountRequested = false;
          try {
            if (JSON.parse(localStorage.getItem("dabimasFactor"))) {
              await this.restoreInputData();
            }
            if (JSON.parse(localStorage.getItem("dabimasMemo"))) {
              const parseArray = JSON.parse(localStorage.getItem("dabimasMemo"));
              this.inputed = parseArray;
            } else {
              this.inputed = Array.from(new Array(32).fill(null));
            }
            if (localStorage.getItem("dabimasMemoStallion")) {
              this.inputedMemoStallion = localStorage.getItem(
                "dabimasMemoStallion"
              );
            } else {
              this.inputedMemoStallion = null;
            }
            if (localStorage.getItem("dabimasMemoBroodmare")) {
              this.inputedMemoBroodmare = localStorage.getItem(
                "dabimasMemoBroodmare"
              );
            } else {
              this.inputedMemoBroodmare = null;
            }
            this.restoreManualInbreedState();
          } finally {
            this.deferInbreedCount = false;
            if (this.deferredInbreedCountRequested) {
              this.dispInbreedFactorCounts();
            }
          }
        },
        c1: function () {
          return new Promise((resolve, reject) => {
            // jsonファイル読み込みが終わるまで非同期処理を待つ（async/await）
            // await this.dbinitializer();
            this.dbinitializer();
            resolve(() => {});
          });
        },
        c2: function () {
          return new Promise((resolve, reject) => {
            console.log(this.$vuetify.breakpoint.name);
            console.log("window.innerHeight", window.innerHeight);
            resolve((this.windowSize = window.innerHeight));
          });
        },
        c3: function () {
          return new Promise((resolve, reject) => {
            // 因子を数字に変換するmapオブジェクト
            //this.factorMap = new map();
            factorMap.set("", "00");
            factorMap.set("短", "01");
            factorMap.set("速", "02");
            factorMap.set("底", "03");
            factorMap.set("長", "04");
            factorMap.set("適", "05");
            factorMap.set("丈", "06");
            factorMap.set("早", "07");
            factorMap.set("晩", "08");
            factorMap.set("堅", "09");
            factorMap.set("難", "10");
            factorMap.set("走", "11");
            factorMap.set("中", "12");

            // 因子部分のCSS設定
            for (var i = 0; i < this.styleFactorClasses.length; i++) {
              let css = "";
              css = this.getCss(i);
              this.styleFactorClasses[i][0] = `${css} styleFactorClassMain`;
              this.styleFactorClasses[i][1] = `${css} styleFactorClassMain`;
              this.styleFactorClasses[i][2] = `${css} styleFactorClassMain`;
            }

            // 血統理論部分のCSS
            for (var i = 0; i < this.styleParentLineClasses.length; i++) {
              let css = "";
              css = this.getCss(i);
              this.styleParentLineClasses[i] = `${css} styleParentLine`;
            }

            // インブリードボタン部分のCSS
            for (var i = 0; i < this.styleInbreedButtonClasses.length; i++) {
              let css = "";
              css = this.getCss(i);
              this.styleInbreedButtonClasses[i] = `${css} styleInbreedButton`;
            }
          });
        },
        c4: async function () {
          if (!window.localStorage) {
            return;
          }
          await this.refreshLocalDataFromStorage();
        },
        // ハート（強制インブリード）ボタンクリック時
        handleInbreedButtonClick: function (index) {
          // それぞれのボタンコンポーネントのキーを更新（再レンダリングさせたいから）
          const changedIsButtonClicked =
            this.isInbreedButtonClicked[index] * -1;
          if (changedIsButtonClicked === 1) {
            this.$set(this.dispColor, index, "inbreed");
            this.inbreedList[index] = {
              ...this.selected[index],
              selfInbreed: true,
            };
          } else {
            this.$set(this.dispColor, index, "");
            this.inbreedList[index] = null;
          }

          // async/await関数を定義
          const dispFunction = async () => {
            // インブリード本数判定表示
            await this.dispInbreedFactorCounts();
            // フラグを反転結果
            this.$set(this.isInbreedButtonClicked, index, changedIsButtonClicked);
            this.reload++;
            this.persistManualInbreedState();
          };
          // async/await関数を実行
          dispFunction().catch(() => {
            this.persistManualInbreedState();
          });
        },

        // 復元処理
        restoreInputData: async function () {
          const parseArray = JSON.parse(localStorage.getItem("dabimasFactor"));
          // ローカルストレージから取得したものでnull要素は排除してからセット
          this.horses = [
            ...Array.from(this.horsesBase),
            ...parseArray.filter((v) => v),
          ];
          this.stallions = [
            ...Array.from(this.stallionsBase),
            ...parseArray.filter((v) => v),
          ];
          this.broodmares = [
            ...Array.from(this.broodmaresBase),
            parseArray[16] ? parseArray[16] : "",
          ];
          this.horseDataLists = [this.horses, this.stallions, this.broodmares];
          this.selected = JSON.parse(localStorage.getItem("dabimasFactor"));
          this.category = JSON.parse(localStorage.getItem("dabimasFactorCategory"));

          // 因子・親系統を詰める
          this.selected.map((element, index) => {
            for (let i = 0; i < 3; i++) {
              this.setFactorName(index, i, element?.factors[i]);
              this.setFactorCd(
                index,
                i,
                factorMap.get(element?.factors[i]) ?? "00"
              );
              this.setFactorCss(
                index,
                i,
                this.fillInFactorCells(this.factorCd[index][i], index)
              );
            }
            this.setParentLine(
              index,
              this.judgeSetParentLine(element?.parentLine, index)
            );
          });

          // カウントした画面に表示させる
          this.factorNumtoString = this.dispFactorCounts(this.factorCd);
          this.categoryNumtoString = this.dispCategoryCount();

          // クロスを判定して表示させる
          await this.dispInbreed();

          this.restoreManualInbreedState();

          // 配合理論を求めて画面に表示させる
          this.dispTheory();
        },

        initializer() {
          // localStorageをクリア
          localStorage.removeItem("dabimasFactor");
          localStorage.removeItem("dabimasMemo");
          localStorage.removeItem("dabimasMemoStallion");
          localStorage.removeItem("dabimasMemoBroodmare");
          localStorage.removeItem(MANUAL_INBREED_STORAGE_KEY);

          this.selected = Array.from(new Array(32).fill(null));
          this.category = Array.from(new Array(32).fill(null));
          // memo欄
          this.inputed = Array.from(new Array(32).fill(null));
          this.inputedMemoStallion = null;
          this.inputedMemoBroodmare = null;

          this.dispColor = Array.from(new Array(32).fill(""));
          // baseをコピーする
          this.stallions = [...this.stallionsBase];
          this.broodmares = [...this.broodmaresBase];
          this.horses = [...this.horsesBase];
          this.horseDataLists = [this.horses, this.stallions, this.broodmares];

          // 因子部分のCSS初期設定
          for (var i = 0; i < this.styleFactorClasses.length; i++) {
            let css = "";
            css = this.getCss(i);
            this.$set(this.styleFactorClasses[i], 0, `${css} styleFactorClassMain`);
            this.$set(this.styleFactorClasses[i], 1, `${css} styleFactorClassMain`);
            this.$set(this.styleFactorClasses[i], 2, `${css} styleFactorClassMain`);
          }

          // 血統理論部分のCSS初期設定
          for (var i = 0; i < this.styleParentLineClasses.length; i++) {
            let css = "";
            css = this.getCss(i);
            this.$set(this.styleParentLineClasses, i, `${css} styleParentLine`);
          }

          // factorNameを二次元配列で定義
          this.factorName = Array.from(new Array(32), () =>
            new Array(3).fill("")
          );

          // 合計因子数表示
          // this.factorNumtoString = Array.from(new Array(10).fill("00"));
          this.factorNumtoString = Array.from(new Array(12).fill("00"));

          // インブリード因子数表示
          // this.inbreedFactorNumtoString = Array.from(new Array(10).fill("00"));
          this.inbreedFactorNumtoString = Array.from(new Array(12).fill("00"));

          // 子系統数
          this.categoryNumtoString = "00";

          // 合計因子数内部変数
          this.factorCd = Array.from(new Array(32), () =>
            new Array(3).fill("00")
          );
          // 親系統表示
          this.parentLines = Array.from(new Array(32).fill(""));

          // 理論表示
          this.styleThoeryClass = "";
          // インブリードされているところを格納する変数
          this.inbreedList = Array.from(new Array(32).fill(null));
          this.sameNameGroups = {
            byIndex: [[], []],
            indexes: [],
            special: {
              sameName: {
                byGroup: [],
                byIndex: [],
              },
            },
          };
          this.sameNameSpecialChecks = [];
          this.sameNameSpecialChecksByIndex = Array.from(
            new Array(32).fill(false)
          );

          // インブリードボタン押下フラグを一次元配列で定義（-1：未クリック　1：クリック　0:使用不可）
          this.isInbreedButtonClicked = Array.from(new Array(32).fill(0));
          // 子系統を表示させるフラグ
          this.dispCategory = 0;

          this.reload++;
        },
        handleClick() {
          this.dispCategory++;
        },
        getCss: function (i) {
          let css = "";
          switch (i) {
            case 0:
              css = "factor_AliceBlue";
              break;
            // （+ 16）は牝馬のほう
            case 0 + 16:
              css = "factor_SalmonPink";
              break;
            // （+ 16）は牝馬のほう
            case 1:
            case 3:
            case 5:
            case 7:
            case 1 + 16:
            case 3 + 16:
            case 5 + 16:
            case 7 + 16:
              css = "factor_omoshiro";
              break;
            case 9:
            case 11:
            case 13:
            case 15:
              css = "factor_migoto";
              break;
            default:
              css = "factor_horse";
              break;
          }
          return css;
        },

        dbinitializer() {
          fetch("./json/dabimasFactor.json")
            .then((response) => {
              return response.json();
            })
            .then((json) => {
              // jsonから取得 - Object.freeze()でリアクティブシステムのオーバーヘッドを削減
              const horsesList = json.horseLists;
              // 各馬データをフリーズ（変更されないため）
              horsesList.forEach(horse => Object.freeze(horse));
              this.horsesBase = Object.freeze(horsesList);
              //this.allHorses = [...this.allHorsesBase];
              this.horses = this.horsesBase.filter(function (horse) {
                return horse.sex === "0" || horse.sex === "1";
              });

              // 牡馬だけを抽出
              this.stallionsBase = Object.freeze(this.horses.filter(function (horse) {
                return horse.sex === "0";
              }));
              this.stallions = [...this.stallionsBase];

              // 牝馬だけを抽出
              this.broodmaresBase = Object.freeze(this.horses.filter(function (horse) {
                return horse.sex === "1";
              }));
              this.broodmares = [...this.broodmaresBase];

              this.horseDataLists = [
                this.horses,
                this.stallions,
                this.broodmares,
              ];

              // 保存されていた場合はリストア処理を行う
              this.c4();
            });

            // 全兄弟データを読み込む
            fetch("./json/brosData.json")
            .then((response) => {
              return response.json();
            })
            .then((json) => {
              // jsonから取得 - フリーズして変更不可にする
              const brosDataList = json.brosData;
              brosDataList.forEach(bros => Object.freeze(bros));
              this.brosData = Object.freeze(brosDataList);
            });
        },
        memoChange: function (index, input) {
          this.$set(this.inputed, index, event.target.value);
          localStorage.setItem("dabimasMemo", JSON.stringify(this.inputed));
        },
        memoChangeStallion: function (input) {
          this.inputedMemoStallion = input;
          localStorage.setItem("dabimasMemoStallion", this.inputedMemoStallion);
        },
        memoChangeBroodmare: function (input) {
          this.inputedMemoBroodmare = input;
          localStorage.setItem("dabimasMemoBroodmare", this.inputedMemoBroodmare);
        },
        // ドロップダウンリスト選択時
        // onChange: function (sex, id, horseData, event) {
        onChange: function (sex, id, horseData) {
          this.onChangeMain(sex, id, horseData);
        },

        // 選択時のメイン処理
        onChangeMain: async function (sex, id, horseData) {
          const targetIndex = Number(id) + Number(sex) * 16;
          if (Number.isInteger(targetIndex)) {
            this.$set(this.isInbreedButtonClicked, targetIndex, -1);
            this.$set(this.dispColor, targetIndex, "");
            this.$set(this.inbreedList, targetIndex, null);
            this.clearManualInbreedForIndex(targetIndex);
          }
          if (horseData) {
            // リストにセットされた場合
            // 血統表データセット用に詰め替える
            console.time('setDataForPedigree');
            const dataForPedigree = this.setDataForPedigree(sex, id, horseData);
            console.timeEnd('setDataForPedigree');
            // 血統表にデータをセットする
            console.time('setPedigree');
            this.setPedigree(sex, id, dataForPedigree);
            console.timeEnd('setPedigree');
          } else {
            // リストを空にした場合（削除モード）
            this.deleteHorses(sex, id);
          }

          console.time('画面表示');
          // カウントした画面に表示させる
          this.factorNumtoString = this.dispFactorCounts(this.factorCd);
          // カウントした子系統数を表示させる
          this.categoryNumtoString = this.dispCategoryCount();
          console.timeEnd('画面表示');

          console.time('クロス');
          // クロスを判定して表示させる
          await this.dispInbreed();
          console.timeEnd('クロス');

          this.restoreManualInbreedState();

          console.time('理論');
          // 配合理論を求めて画面に表示させる
          this.dispTheory();
          console.timeEnd('理論');

          // 内容をローカルに保存する
          localStorage.setItem("dabimasFactor", JSON.stringify(this.selected));
          localStorage.setItem("dabimasFactorCategory",JSON.stringify(this.category));
        },

        // リストから削除
        deleteHorses: function (sex, id) {
          // 削除したいUUIDを取得する
          const deleteUuid = this.selected[id + sex * 16].uuid;

          // 削除するUUIDを持つリストを検索する
          const deleteHorseList = this.selected.filter(
            (horse) => horse && horse.uuid === deleteUuid
          );
          // 該当するものがあれば、それに該当するものを削除する
          for (const deleteHorse of deleteHorseList) {
            const deleteIndex = deleteHorse.index;

            // リストから選択できない種牡馬をリストから削除する
            // 削除したい名前をセット
            const deleteName = this.selected[deleteIndex]?.name;
            const deleteSubName = this.selected[deleteIndex]?.subName;
            const deleteDisabled = this.selected[deleteIndex]?.disabled;

            // ほかのところで同じ馬が設定されているのかチェック
            const duplicateCheck = this.selected.filter(
              (horse) =>
                horse &&
                horse.name === deleteName &&
                horse.subName === deleteSubName &&
                horse.uuid !== deleteUuid
            );

            // ほかのところで同じ馬が設定されていない場合は配列から削除する
            if (duplicateCheck.length === 0) {
              // 削除したい名前が配列のどこにあるのか取得
              const deleteHorsesIndex = this.horses.findIndex(
                (object) =>
                  object?.name === deleteName &&
                  object?.subName === deleteSubName &&
                  object?.disabled === true
              );
              const deleteStallionsIndex = this.stallions.findIndex(
                (object) =>
                  object?.name === deleteName &&
                  object?.subName === deleteSubName &&
                  object?.disabled === true
              );
              const deleteBroodmaresIndex = this.broodmares.findIndex(
                (object) =>
                  object?.name === deleteName && object?.disabled === true
              );

              // 取得した配列の位置のものを削除する
              if (deleteHorsesIndex !== -1) {
                this.horses.splice(deleteHorsesIndex, 1);
              }
              if (deleteStallionsIndex !== -1) {
                this.stallions.splice(deleteStallionsIndex, 1);
              }
              if (deleteBroodmaresIndex !== -1) {
                this.broodmares.splice(deleteBroodmaresIndex, 1);
              }
            }
            // リストから消す
            this.$set(this.selected, deleteHorse.index, null);
            this.$set(this.category, deleteHorse.index, null);

            this.$set(this.factorName[deleteIndex], 0, '');
            this.$set(this.factorName[deleteIndex], 1, '');
            this.$set(this.factorName[deleteIndex], 2, '');

            this.$set(this.factorCd[deleteIndex], 0, '');
            this.$set(this.factorCd[deleteIndex], 1, '');
            this.$set(this.factorCd[deleteIndex], 2, '');

            this.$set(this.parentLines, deleteIndex, '');
            // CSSを初期化
            let css = "";
            css = this.getCss(deleteIndex);
            this.$set(this.styleFactorClasses[deleteIndex], 0, `${css} styleFactorClassMain`);
            this.$set(this.styleFactorClasses[deleteIndex], 1, `${css} styleFactorClassMain`);
            this.$set(this.styleFactorClasses[deleteIndex], 2, `${css} styleFactorClassMain`);
            this.$set(this.styleParentLineClasses, deleteIndex, `${css} styleParentLine`);
            this.$set(this.isInbreedButtonClicked, deleteIndex, -1);
            this.$set(this.dispColor, deleteIndex, "");
            this.$set(this.inbreedList, deleteIndex, null);
            this.clearManualInbreedForIndex(deleteIndex);
          }
          this.horseDataLists = [this.horses, this.stallions, this.broodmares];
        },
        // インブリード表示
        dispInbreed: async function () {
          //
          // let retInbreedArray = [];
          let retInbreedCount = 0;
          // 血統表が全部埋まっている場合に判定処理を行う
          if (this.selected.every((e) => e)) {
            // インブリードボタンクリック済フラグを未クリックに設定
            this.isInbreedButtonClicked = Array.from(new Array(32).fill(-1));
            // インブリードされているところを格納する変数
            this.inbreedList = Array.from(new Array(32).fill(null));
            // インブリードの色も初期化
            this.dispColor = Array.from(new Array(32).fill(""));
            // インブリード判定処理のメイン
            console.time('インブリード判定');
            retInbreedCount = this.judgeInbreed();
            console.timeEnd('インブリード判定');
          } else {
            // インブリードボタンクリック済フラグを非活性モードに設定
            this.isInbreedButtonClicked = Array.from(new Array(32).fill(0));
            this.reload++;
            // インブリードの色も初期化
            this.dispColor = Array.from(new Array(32).fill(""));
            // インブリード因子数表示（中長因子も）
            this.inbreedFactorNumtoString = Array.from(new Array(12).fill("00"));
            // インブリードされているところを格納する変数
            this.inbreedList = Array.from(new Array(32).fill(null));
            this.sameNameGroups = {
              byIndex: [[], []],
              indexes: [],
              special: {
                sameName: {
                  byGroup: [],
                  byIndex: [],
                },
              },
            };
            this.sameNameSpecialChecks = [];
            this.sameNameSpecialChecksByIndex = Array.from(
              new Array(32).fill(false)
            );
          }

          console.time('インブリード表示');
          // インブリードが発生した場合
          if (retInbreedCount > 0) {
            await this.dispInbreedFactorCounts();
          }
          console.timeEnd('インブリード表示');
        },

        // インブリード本数表示
        dispInbreedFactorCounts: function () {
          if (this.deferInbreedCount) {
            this.deferredInbreedCountRequested = true;
            return;
          }
          this.performInbreedFactorCounts();
        },
        performInbreedFactorCounts: function () {
          
          const indexSet = new Set();

          this.sameNameGroups.forEach(group => {
            group.forEach(node => {
              if (node && node.index !== undefined) {
                indexSet.add(node.index);
              }
            });
          });
          this.siblingGroups.forEach(group => {
            group.forEach(node => {
              if (node && node.index !== undefined) {
                indexSet.add(node.index);
              }
            });
          });
          const allIndexes = Array.from(indexSet);

          // 自動クロスされたところのボタンを非活性化させる
          allIndexes.forEach(element => {
            this.isInbreedButtonClicked[element] = 0;
          });

          const mergedGroupsByName = new Map();

          // sameNameGroupsを追加
          this.sameNameGroups.forEach(group => {
            if (group.length > 0 && group[0]?.name) {
              const name = group[0].name;
              if (!mergedGroupsByName.has(name)) {
                mergedGroupsByName.set(name, []);
              }
              const existingIndexes = mergedGroupsByName.get(name).map(n => n.index);
              group.forEach(node => {
                if (node && node.index !== undefined && !existingIndexes.includes(node.index)) {
                  mergedGroupsByName.get(name).push(node);
                  existingIndexes.push(node.index);
                }
              });
            }
          });

          // siblingGroupsを追加
          this.siblingGroups.forEach(group => {
            if (group.length > 0 && group[0]?.name) {
              const name = group[0].name;
              if (!mergedGroupsByName.has(name)) {
                mergedGroupsByName.set(name, []);
              }
              const existingIndexes = mergedGroupsByName.get(name).map(n => n.index);
              group.forEach(node => {
                if (node && node.index !== undefined && !existingIndexes.includes(node.index)) {
                  mergedGroupsByName.get(name).push(node);
                  existingIndexes.push(node.index);
                }
              });
            }
          });

          // Map → 配列に変換
          const mergedGroups = Array.from(mergedGroupsByName.values());

          // 空欄、数字、(で始まるものを除外する
          const excludeString = /^$|^\d*$|^\(.+?\)/;
          let inbreedArray = [];
          mergedGroups.flat().flat().forEach(element => {
            if (element) {
              this.inbreedList[element.index] = element;
            }
          });

          this.inbreedList.map((value) => {
            if (value) {
              // subNameが(で始まる場合(繫殖牝馬選択時)や数字の因名被りなのでそれは削除する
              inbreedArray.push({
                name: value.name,
                subName: excludeString.test(value.subName)
                  ? "dummy"
                  : value.subName,
                factors: value.factors,
                selfInbreed: false,
              });
            }
          });

          const factorCd = Array.from(new Array(32), () =>
            new Array(3).fill("00")
          );
          // 重複を削除する
          const inbreedArraySimple = inbreedArray.filter(
            ({ name, subName }, i) =>
              i ===
              inbreedArray.findIndex(
                (e) => e?.name === name && e?.subName === subName
              )
          );

          // 因子をコード変換する。Ex.速→02にさせる
          if (inbreedArraySimple) {
            inbreedArraySimple.map((element, index) => {
              factorCd[index][0] = factorMap.get(element?.factors[0]) ?? "00";
              factorCd[index][1] = factorMap.get(element?.factors[1]) ?? "00";
              factorCd[index][2] = factorMap.get(element?.factors[2]) ?? "00";
            });
          }

          // インブリードした因子数をカウントする
          this.inbreedFactorNumtoString = this.dispFactorCounts(factorCd);

          console.log(this.inbreedFactorNumtoString);
        },

        // インブリード判定
        judgeInbreed: function () {
          // 世代対応表（indexから世代を取得）
          const generationMap = [
            1, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
            1, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
          ];

          // 選択済み32枠を牡馬（0-15）・牝馬（16-31）に分割
          const stallionsArray = [];
          const broodmaresArray = [];
          
          for (let loopIndex = 0; loopIndex < this.selected.length; loopIndex++) {
            const value = this.selected[loopIndex];
            if (!value || !value.name) {
              continue;
            }
            if (loopIndex < 16) {
              stallionsArray.push(value);
            } else {
              broodmaresArray.push(value);
            }
          }

          // 片側しか埋まっていない場合は何も判定せず終了
          if (stallionsArray.length === 0 || broodmaresArray.length === 0) {
            this.sameNameGroups = [];
            this.siblingGroups = [];
            this.sameNameSpecialChecks = [];
            this.sameNameSpecialChecksByIndex = Array.from(new Array(32).fill(false));
            this.dispColor = Array.from(new Array(32).fill(""));
            return 0;
          }

          // 子孫ノード取得関数（特定indexから子孫をすべて取得）
          const getAncestorIndexes = (startIndex) => {
            const ancestors = new Set();
            
            // 親子関係マッピング（dummy母も含む完全なツリー構造）
            // 実際のindex: 0-15 (父側), 16-31 (母側)
            // 仮想母index: 100番台 (父側の母), 200番台 (母側の母)
            const parentChildMap = {
              // 父側（0-15）
              0: [1, 100],        // 本馬 → 父[1], 母[100]
              100: [3, 107],      // [0]の母 → 父[3], 母[107]
              107: [7, 115],      // [0]の母の母 → 父[7], 母[115]
              115: [15],          // [0]の母の母の母 → 父[15]のみ
              
              1: [2, 101],        // [1] → 父[2], 母[101]
              101: [5, 111],      // [1]の母 → 父[5], 母[111]
              111: [11],          // [1]の母の母 → 父[11]のみ
              
              2: [4, 102],        // [2] → 父[4], 母[102]
              102: [9],           // [2]の母 → 父[9]のみ
              
              3: [6, 103],        // [3] → 父[6], 母[103]
              103: [13],          // [3]の母 → 父[13]のみ
              
              4: [8],             // [4] → 父[8]のみ
              5: [10],            // [5] → 父[10]のみ
              6: [12],            // [6] → 父[12]のみ
              7: [14],            // [7] → 父[14]のみ
              
              // 母側（16-31）
              16: [17, 200],      // 本馬 → 父[17], 母[200]
              200: [19, 207],     // [16]の母 → 父[19], 母[207]
              207: [23, 215],     // [16]の母の母 → 父[23], 母[215]
              215: [31],          // [16]の母の母の母 → 父[31]のみ
              
              17: [18, 201],      // [17] → 父[18], 母[201]
              201: [21, 211],     // [17]の母 → 父[21], 母[211]
              211: [27],          // [17]の母の母 → 父[27]のみ
              
              18: [20, 202],      // [18] → 父[20], 母[202]
              202: [25],          // [18]の母 → 父[25]のみ
              
              19: [22, 203],      // [19] → 父[22], 母[203]
              203: [29],          // [19]の母 → 父[29]のみ
              
              20: [24],           // [20] → 父[24]のみ
              21: [26],           // [21] → 父[26]のみ
              22: [28],           // [22] → 父[28]のみ
              23: [30],           // [23] → 父[30]のみ
            };
            
            // 再帰的に祖先を収集（parentChildMapは「自分→親」の関係）
            const collectAncestors = (idx) => {
              const parents = parentChildMap[idx];
              if (parents) {
                parents.forEach(parentIdx => {
                  if (!ancestors.has(parentIdx)) {
                    ancestors.add(parentIdx);
                    collectAncestors(parentIdx);
                  }
                });
              }
            };
            
            collectAncestors(startIndex);
            return ancestors;
          };

          // クロス候補を検出（名前一致 + fullBrothers一致 + 繫殖牝馬×種牡馬全兄妹）
          const crossCandidates = [];
          const siblingPairs = new Set(); // 全兄弟で判定済みのペアを記録
          
          // ========================================
          // 1. 繫殖牝馬×種牡馬の全兄妹クロス検出（最優先）
          // ========================================
          const broodmareGroups = {}; // subName → [indexes]のマップ
          
          // 父側で繫殖牝馬の血統表を検出
          for (let sIdx = 0; sIdx < stallionsArray.length; sIdx++) {
            const stallion = stallionsArray[sIdx];
            if (!stallion || !stallion.subName) continue;
            
            // subNameが`(`で始まる → 繫殖牝馬の血統表
            if (stallion.subName.startsWith('(') && stallion.subName.endsWith(')')) {
              const broodmareName = stallion.subName.slice(1, -1); // "(ダンスパートナー)" → "ダンスパートナー"
              
              if (!broodmareGroups[broodmareName]) {
                broodmareGroups[broodmareName] = [];
              }
              broodmareGroups[broodmareName].push(stallion.index);
            }
          }
          
          // 各繫殖牝馬について、母側で全兄妹を探す
          for (const [broodmareName, broodmareIndexes] of Object.entries(broodmareGroups)) {
            for (let bIdx = 0; bIdx < broodmaresArray.length; bIdx++) {
              const broodmare = broodmaresArray[bIdx];
              if (!broodmare || !broodmare.name) continue;
              
              let isSibling = false;
              
              // broodmareのfullBrothersにbroodmareNameがある
              if (Array.isArray(broodmare.fullBrothers) && broodmare.fullBrothers.includes(broodmareName)) {
                isSibling = true;
              }
              
              // broodmareのfullSistersにbroodmareNameがある
              if (Array.isArray(broodmare.fullSisters) && broodmare.fullSisters.includes(broodmareName)) {
                isSibling = true;
              }
              
              if (isSibling) {
                // 種牡馬側のみをsiblingGroupsに追加
                const broodmareGlobalIdx = broodmare.index;
                const broodmareGen = generationMap[broodmareGlobalIdx];
                
                crossCandidates.push({
                  name: `${broodmareName}×${broodmare.name}(全兄妹)`,
                  type: 'broodmare-stallion-sibling',
                  stallionIndex: null, // 繫殖牝馬側は追加しない
                  broodmareIndex: broodmareGlobalIdx,
                  stallionGen: 0,
                  broodmareGen: broodmareGen,
                  generationSum: broodmareGen, // 母側のみでソート
                  stallionNode: null,
                  broodmareNode: broodmare,
                  broodmareGroupIndexes: broodmareIndexes, // 繫殖牝馬側の全indexを保持
                });
              }
            }
          }
          
          // ========================================
          // 2. fullBrothers一致でクロス検出（先に処理）
          // ========================================
          for (let sIdx = 0; sIdx < stallionsArray.length; sIdx++) {
            const stallion = stallionsArray[sIdx];
            if (!stallion || !stallion.name) continue;
            
            for (let bIdx = 0; bIdx < broodmaresArray.length; bIdx++) {
              const broodmare = broodmaresArray[bIdx];
              if (!broodmare || !broodmare.name) continue;
              
              let isSibling = false;
              
              // stallionのfullBrothersにbroodmareの名前がある
              if (Array.isArray(stallion.fullBrothers) && stallion.fullBrothers.includes(broodmare.name)) {
                isSibling = true;
              }
              
              // broodmareのfullBrothersにstallionの名前がある
              if (Array.isArray(broodmare.fullBrothers) && broodmare.fullBrothers.includes(stallion.name)) {
                isSibling = true;
              }
              
              if (isSibling) {
                const stallionGlobalIdx = stallion.index;
                const broodmareGlobalIdx = broodmare.index;
                const stallionGen = generationMap[stallionGlobalIdx];
                const broodmareGen = generationMap[broodmareGlobalIdx];
                
                // 重複チェック（既に追加されていないか）
                const exists = crossCandidates.some(c => 
                  c.stallionIndex === stallionGlobalIdx && 
                  c.broodmareIndex === broodmareGlobalIdx
                );
                
                if (!exists) {
                  crossCandidates.push({
                    name: `${stallion.name}×${broodmare.name}(兄弟)`,
                    type: 'sibling',
                    stallionIndex: stallionGlobalIdx,
                    broodmareIndex: broodmareGlobalIdx,
                    stallionGen: stallionGen,
                    broodmareGen: broodmareGen,
                    generationSum: stallionGen + broodmareGen,
                    stallionNode: stallion,
                    broodmareNode: broodmare,
                  });
                  
                  // このペアを記録
                  siblingPairs.add(`${stallionGlobalIdx}-${broodmareGlobalIdx}`);
                }
              }
            }
          }
          
          // 名前一致でクロス検出
          for (let sIdx = 0; sIdx < stallionsArray.length; sIdx++) {
            const stallion = stallionsArray[sIdx];
            if (!stallion || !stallion.name) continue;
            
            for (let bIdx = 0; bIdx < broodmaresArray.length; bIdx++) {
              const broodmare = broodmaresArray[bIdx];
              if (!broodmare || !broodmare.name) continue;
              
              if (stallion.name === broodmare.name) {
                const stallionGlobalIdx = stallion.index;
                const broodmareGlobalIdx = broodmare.index;
                
                // 全兄弟で既に判定済みのペアはスキップ
                if (siblingPairs.has(`${stallionGlobalIdx}-${broodmareGlobalIdx}`)) {
                  continue;
                }
                
                const stallionGen = generationMap[stallionGlobalIdx];
                const broodmareGen = generationMap[broodmareGlobalIdx];
                
                crossCandidates.push({
                  name: stallion.name,
                  type: 'sameName',
                  stallionIndex: stallionGlobalIdx,
                  broodmareIndex: broodmareGlobalIdx,
                  stallionGen: stallionGen,
                  broodmareGen: broodmareGen,
                  generationSum: stallionGen + broodmareGen,
                  stallionNode: stallion,
                  broodmareNode: broodmare,
                });
              }
            }
          }

          // 世代合計でソート（繫殖牝馬×種牡馬全兄妹クロスを最優先、その後世代合計順）
          crossCandidates.sort((a, b) => {
            // 繫殖牝馬×種牡馬の全兄妹クロスを最優先
            if (a.type === 'broodmare-stallion-sibling' && b.type !== 'broodmare-stallion-sibling') {
              return -1;
            }
            if (a.type !== 'broodmare-stallion-sibling' && b.type === 'broodmare-stallion-sibling') {
              return 1;
            }
            // それ以外は世代合計順
            return a.generationSum - b.generationSum;
          });

          // 祖先除外ロジックを適用
          const excludedNodes = new Set();
          const broodmareGroupIndexes = new Set(); // 繫殖牝馬側のindexを記録（filterで使用）
          const recognizedCrosses = [];
          
          for (const cross of crossCandidates) {
            // 繫殖牝馬×種牡馬の全兄妹クロスの場合
            if (cross.type === 'broodmare-stallion-sibling') {
              // 種牡馬側のみをsiblingGroupsに追加
              recognizedCrosses.push(cross);
              
              // 繫殖牝馬側の全ての馬を記録し、その祖先も除外
              cross.broodmareGroupIndexes.forEach(idx => {
                broodmareGroupIndexes.add(idx);
                
                // この繫殖牝馬の祖先も除外
                const ancestors = getAncestorIndexes(idx);
                ancestors.forEach(ancestorIdx => {
                  excludedNodes.add(ancestorIdx);
                });
              });
              
              // 種牡馬側の全ての祖先を除外リストに追加
              const broodmareAncestors = getAncestorIndexes(cross.broodmareIndex);
              broodmareAncestors.forEach(idx => {
                excludedNodes.add(idx);
              });
              
              continue;
            }
            
            // 通常のクロス判定（名前一致・fullBrothers一致）
            // どちらかのノードが除外リストに含まれているかチェック
            const stallionExcluded = excludedNodes.has(cross.stallionIndex);
            const broodmareExcluded = excludedNodes.has(cross.broodmareIndex);
            
            // 両方とも除外されている場合のみスキップ
            if (stallionExcluded && broodmareExcluded) {
              continue;
            }
            
            // インブリード認定
            recognizedCrosses.push(cross);
            
            // 使用したノードの祖先を除外リストに追加
            const stallionAncestors = getAncestorIndexes(cross.stallionIndex);
            const broodmareAncestors = getAncestorIndexes(cross.broodmareIndex);
            
            stallionAncestors.forEach(idx => {
              excludedNodes.add(idx);
            });
            
            broodmareAncestors.forEach(idx => {
              excludedNodes.add(idx);
            });
          }

          // ===== 例外パターンのクロス判定 =====
          // ヘルパー関数：indexから世代を計算
          const getGenerationFromIndex = (index) => {
            if (index === 0 || index === 16) return 1;
            if (index === 1 || index === 17) return 2;
            if ((index >= 2 && index <= 3) || (index >= 18 && index <= 19)) return 3;
            if ((index >= 4 && index <= 7) || (index >= 20 && index <= 23)) return 4;
            if ((index >= 8 && index <= 15) || (index >= 24 && index <= 31)) return 5;
            return 0;
          };
          
          // ヘルパー関数：indexから父側/母側を判定
          const getSideFromIndex = (index) => {
            return index < 16 ? 'stallion' : 'broodmare';
          };
          
          // ヘルパー関数：世代条件をチェック
          const checkGenerationCondition = (gen, targetGen, operator) => {
            switch (operator) {
              case '<': return gen < targetGen;
              case '<=': return gen <= targetGen;
              case '>': return gen > targetGen;
              case '>=': return gen >= targetGen;
              case '==': return gen === targetGen;
              default: return false;
            }
          };
          
          // 例外パターンのチェック
          this.inbreedExceptions.forEach(exception => {
            // trigger条件のチェック：トリガー馬のindexを検索
            const triggerHorseIndexes = [];
            stallionsArray.forEach(horse => {
              if (horse && horse.name === exception.trigger.horse) {
                triggerHorseIndexes.push(horse.index);
              }
            });
            broodmaresArray.forEach(horse => {
              if (horse && horse.name === exception.trigger.horse) {
                triggerHorseIndexes.push(horse.index);
              }
            });
            
            // トリガー条件に一致するindexをフィルタ
            const matchingTriggers = triggerHorseIndexes.filter(idx => {
              const gen = getGenerationFromIndex(idx);
              const side = getSideFromIndex(idx);
              
              // 世代条件のチェック
              if (!checkGenerationCondition(gen, exception.trigger.generation, exception.trigger.operator)) {
                return false;
              }
              
              // side条件のチェック
              if (exception.trigger.side === 'stallion' && side !== 'stallion') return false;
              if (exception.trigger.side === 'broodmare' && side !== 'broodmare') return false;
              // 'either'の場合はどちらでもOK
              
              return true;
            });
            
            if (matchingTriggers.length === 0) return;
            
            // target馬のチェック
            matchingTriggers.forEach(triggerIdx => {
              const triggerSide = getSideFromIndex(triggerIdx);
              
              // target側を決定
              let targetSide;
              if (exception.target.side === 'opposite') {
                targetSide = triggerSide === 'stallion' ? 'broodmare' : 'stallion';
              } else if (exception.target.side === 'same') {
                targetSide = triggerSide;
              } else if (exception.target.side === 'either') {
                targetSide = null; // 両方チェック
              } else {
                return;
              }
              
              // target馬のindexを検索
              const targetIndexes = [];
              const searchArrays = targetSide === 'stallion' ? [stallionsArray] 
                                : targetSide === 'broodmare' ? [broodmaresArray]
                                : [stallionsArray, broodmaresArray];
              
              searchArrays.forEach(arr => {
                arr.forEach(horse => {
                  if (horse && horse.name === exception.target.horse) {
                    targetIndexes.push({index: horse.index, node: horse});
                  }
                });
              });
              
              // 各target馬についてクロス認定
              targetIndexes.forEach(target => {
                const targetIdx = target.index;
                const targetNode = target.node;
                const targetActualSide = getSideFromIndex(targetIdx);
                
                // 除外リストに含まれているかチェック
                if (excludedNodes.has(targetIdx)) {
                  return; // 既に除外されている場合はスキップ
                }
                
                // recognizedCrossesに追加
                const crossData = {
                  name: `${exception.target.horse}(例外:${exception.name})`,
                  type: 'exception',
                  stallionIndex: targetActualSide === 'stallion' ? targetIdx : null,
                  broodmareIndex: targetActualSide === 'broodmare' ? targetIdx : null,
                  stallionNode: targetActualSide === 'stallion' ? targetNode : null,
                  broodmareNode: targetActualSide === 'broodmare' ? targetNode : null,
                  exceptionId: exception.id,
                  displayInSameNameGroups: exception.action.displayInSameNameGroups
                };
                
                recognizedCrosses.push(crossData);
                
                // 祖先を除外
                if (exception.action.excludeAncestors) {
                  const ancestors = getAncestorIndexes(targetIdx);
                  ancestors.forEach(idx => excludedNodes.add(idx));
                }
              });
            });
          });

          // sameNameGroupsとsiblingGroupsに分類
          const sameNameGroupsFinal = [];
          const siblingGroupsFinal = [];
          
          // 各馬名について、異なるselectedHorseでクロスしているかチェック
          const namesWithDifferentSelectedHorseCross = new Set();
          
          recognizedCrosses.forEach(cross => {
            if (cross.type === 'sameName') {
              const stallionSelectedHorse = cross.stallionNode ? cross.stallionNode.selectedHorse : null;
              const broodmareSelectedHorse = cross.broodmareNode ? cross.broodmareNode.selectedHorse : null;
              
              // 異なるselectedHorseのクロスの場合、その馬名を記録
              if (stallionSelectedHorse !== broodmareSelectedHorse && cross.stallionNode && cross.stallionNode.name) {
                namesWithDifferentSelectedHorseCross.add(cross.stallionNode.name);
              }
            }
          });
          
          recognizedCrosses.forEach(cross => {
            if (cross.type === 'broodmare-stallion-sibling') {
              // 繫殖牝馬×種牡馬の全兄妹クロス：種牡馬のみを追加
              siblingGroupsFinal.push([cross.broodmareNode]);
            } else {
              const group = [cross.stallionNode, cross.broodmareNode];
              
              if (cross.type === 'sameName') {
                const horseName = cross.stallionNode ? cross.stallionNode.name : null;
                const hasbroodmareIndex = broodmareGroupIndexes.has(cross.stallionIndex) || 
                                          broodmareGroupIndexes.has(cross.broodmareIndex);
                
                // 繫殖牝馬側のindexを含む場合
                if (hasbroodmareIndex) {
                  // 異なるselectedHorseでもクロスしている場合はsameNameGroupsに含める
                  if (namesWithDifferentSelectedHorseCross.has(horseName)) {
                    sameNameGroupsFinal.push(group);
                  }
                  // 同じselectedHorseでしかクロスしていない場合はsameNameGroupsから除外
                } else {
                  // 繫殖牝馬側のindexを含まない場合は通常通り追加
                  sameNameGroupsFinal.push(group);
                }
              } else if (cross.type === 'exception') {
                // 例外パターンのクロス
                const targetNode = cross.stallionNode || cross.broodmareNode;
                if (cross.displayInSameNameGroups) {
                  sameNameGroupsFinal.push([targetNode]);
                } else {
                  siblingGroupsFinal.push([targetNode]);
                }
              } else {
                siblingGroupsFinal.push(group);
              }
            }
          });

          // sameNameGroupsFinalとsiblingGroupsFinalを名前でグループ化し、JSONから同名の馬を追加
          // 1. sameNameGroupsFinalを名前でグループ化
          const sameNameGroupsByName = new Map(); // name → [nodes]
          sameNameGroupsFinal.forEach(group => {
            group.forEach(node => {
              if (node && node.name) {
                if (!sameNameGroupsByName.has(node.name)) {
                  sameNameGroupsByName.set(node.name, []);
                }
                // 重複チェック（同じindexが既に含まれていないか）
                const existingIndexes = sameNameGroupsByName.get(node.name).map(n => n.index);
                if (!existingIndexes.includes(node.index)) {
                  sameNameGroupsByName.get(node.name).push(node);
                }
              }
            });
          });
          
          // stallionsArrayとbroodmaresArrayから同名の馬を探して追加
          sameNameGroupsByName.forEach((nodes, name) => {
            const existingIndexes = nodes.map(n => n.index);
            [...stallionsArray, ...broodmaresArray].forEach(horse => {
              if (horse && horse.name === name && !existingIndexes.includes(horse.index)) {
                nodes.push(horse);
                existingIndexes.push(horse.index);
              }
            });
          });
          
          // Map → 配列に変換
          const sameNameGroupsFinalGrouped = Array.from(sameNameGroupsByName.values());
          
          // 2. siblingGroupsFinalを名前でグループ化
          const siblingGroupsByName = new Map(); // name → [nodes]
          siblingGroupsFinal.forEach(group => {
            group.forEach(node => {
              if (node && node.name) {
                if (!siblingGroupsByName.has(node.name)) {
                  siblingGroupsByName.set(node.name, []);
                }
                // 重複チェック（同じindexが既に含まれていないか）
                const existingIndexes = siblingGroupsByName.get(node.name).map(n => n.index);
                if (!existingIndexes.includes(node.index)) {
                  siblingGroupsByName.get(node.name).push(node);
                }
              }
            });
          });
          
          // stallionsArrayとbroodmaresArrayから同名の馬を探して追加
          siblingGroupsByName.forEach((nodes, name) => {
            const existingIndexes = nodes.map(n => n.index);
            [...stallionsArray, ...broodmaresArray].forEach(horse => {
              if (horse && horse.name === name && !existingIndexes.includes(horse.index)) {
                nodes.push(horse);
                existingIndexes.push(horse.index);
              }
            });
          });
          
          // Map → 配列に変換
          const siblingGroupsFinalGrouped = Array.from(siblingGroupsByName.values());

          // siblingGroupsFinalGroupedと重複する名前をsameNameGroupsFinalGroupedから削除
          const namesInSiblingGroups = new Set();
          siblingGroupsFinalGrouped.forEach(group => {
            if (group.length > 0 && group[0] && group[0].name) {
              namesInSiblingGroups.add(group[0].name);
            }
          });
          
          // sameNameGroupsFinalGroupedから重複する名前のグループを削除
          const sameNameGroupsFinalFiltered = sameNameGroupsFinalGrouped.filter(group => {
            if (group.length > 0 && group[0] && group[0].name) {
              return !namesInSiblingGroups.has(group[0].name);
            }
            return true;
          });

          // combinedFlatIndexesとcombinedFlatSeenを再構築
          const newCombinedFlatIndexes = [];
          const newCombinedFlatSeen = Array.from(new Array(32).fill(false));
          
          // sameNameGroupsFinalFilteredから全てのindexを収集
          sameNameGroupsFinalFiltered.forEach(group => {
            group.forEach(node => {
              if (node && node.index !== undefined) {
                const horseName = node.name;
                const hasbroodmareIndex = broodmareGroupIndexes.has(node.index);
                
                // 繫殖牝馬側のindexでも、別系統でクロスしている場合は含める
                if (hasbroodmareIndex) {
                  // 異なるselectedHorseでクロスしている場合のみ追加
                  if (namesWithDifferentSelectedHorseCross.has(horseName) && !newCombinedFlatSeen[node.index]) {
                    newCombinedFlatSeen[node.index] = true;
                    newCombinedFlatIndexes.push(node.index);
                  }
                } else {
                  // 繫殖牝馬側のindexでない場合は通常通り追加
                  if (!newCombinedFlatSeen[node.index]) {
                    newCombinedFlatSeen[node.index] = true;
                    newCombinedFlatIndexes.push(node.index);
                  }
                }
              }
            });
          });
          
          // siblingGroupsFinalGroupedから全てのindexを収集
          siblingGroupsFinalGrouped.forEach(group => {
            group.forEach(node => {
              if (node && node.index !== undefined) {
                if (!newCombinedFlatSeen[node.index]) {
                  newCombinedFlatSeen[node.index] = true;
                  newCombinedFlatIndexes.push(node.index);
                }
              }
            });
          });

          // sameNameGroupsFinalFilteredの特殊チェック
          const indexGroupAssignments = [
            1, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
            1, 2, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
          ];

          const evaluateSameNameSpecialCheck = (group) => {
            if (!Array.isArray(group) || group.length === 0) {
              return false;
            }

            const coveredGroups = new Set(
              group
                .map((item) => {
                  if (typeof item?.index !== "number") {
                    return undefined;
                  }
                  return indexGroupAssignments[item.index];
                })
                .filter((value) => typeof value === "number")
            );
            const coverageOk = coveredGroups.has(3) && coveredGroups.has(4) && coveredGroups.has(5);
            if (!coverageOk) {
              return false;
            }

            const factorSet = new Set();
            group.forEach((item) => {
              if (Array.isArray(item?.factors)) {
                item.factors.forEach((factor) => {
                  const normalized = (factor ?? "").trim();
                  if (normalized) {
                    factorSet.add(normalized);
                  }
                });
              }
            });
            return factorSet.size >= 6;
          };

          // sameNameGroupsFinalFilteredの各グループをチェック
          const specialCheckIndexes = [];
          const specialCheckSeen = Array.from(new Array(32).fill(false));
          
          sameNameGroupsFinalFiltered.forEach(group => {
            if (evaluateSameNameSpecialCheck(group)) {
              // 条件を満たすグループのindexを収集
              group.forEach(node => {
                if (node && node.index !== undefined && !specialCheckSeen[node.index]) {
                  specialCheckSeen[node.index] = true;
                  specialCheckIndexes.push(node.index);
                }
              });
            }
          });

          // 結果を保存
          this.sameNameGroups = sameNameGroupsFinalFiltered;
          this.siblingGroups = siblingGroupsFinalGrouped;
          this.sameNameSpecialChecks = specialCheckIndexes;
          this.sameNameSpecialChecksByIndex = specialCheckSeen;

          // クロスが発生した箇所を赤くする
          let inbreedArray = 0;
          newCombinedFlatIndexes.forEach(element => {
            this.$set(this.dispColor, element, "inbreed");
            inbreedArray++;
          });
          // specialCheckIndexes.forEach(element => {
          //   this.$set(this.dispColor, element, "supreme");
          // });

          // インブリード発生数を返す
          return inbreedArray;
        },
        // 配合理論を求めて画面に表示させる
        dispTheory: function () {
          // 使用例
          const S = [
            [
              this.parentLines[1],
              this.parentLines[3],
              this.parentLines[5],
              this.parentLines[7],
            ],
            [
              this.parentLines[9],
              this.parentLines[11],
              this.parentLines[13],
              this.parentLines[15],
            ],
          ];
          const D = [
            [
              this.parentLines[1 + 16],
              this.parentLines[3 + 16],
              this.parentLines[5 + 16],
              this.parentLines[7 + 16],
            ],
            [
              this.parentLines[1 + 16],
              this.parentLines[3 + 16],
              this.parentLines[5 + 16],
              this.parentLines[7 + 16],
            ],
          ];
          const flattenedS = S.flat();
          const flattenedD = D.flat();

          // 血統表全部が埋まっている場合に理論判定
          if (this.selected.every((e) => e)) {
            if (this.sameNameSpecialChecks)
            this.styleThoeryClass = this.compatibility(S, D);
          } else {
            // 理論系統が埋まっていない場合は、空白を設定
            this.styleThoeryClass = "";
          }
        },

        countCommonElements: function (A, B) {
          // AとBに共通する要素を取得する
          const uniqueCommonElements = [
            ...new Set(A.filter((element) => B.includes(element))),
          ];

          // Aに含まれるuniqueCommonElementsの要素数をカウントする
          const countA = uniqueCommonElements.reduce((count, element) => {
            return count + A.filter((a) => a === element).length;
          }, 0);

          // Bに含まれるuniqueCommonElementsの要素数をカウントする
          const countB = uniqueCommonElements.reduce((count, element) => {
            return count + B.filter((b) => b === element).length;
          }, 0);

          // countAとcountBのうち最小値を取得する
          const minCount = Math.min(countA, countB);

          return minCount;
        },

        countUniqueElements: function (A, B) {
          // AとBを結合して和集合を作成
          const union = [...A, ...B];

          // 和集合から重複を除いた集合Dを取得する
          const uniqueElements = [...new Set(union)];

          // 集合Dの要素数を返す
          return uniqueElements.length;
        },

        // Sire, Damは[[面白系統]，[見事系統]]の書式
        // 面白内，見事内は順不同
        // 例えば，ドゥラメンテなら[["Na","Ne","Ro","Ns"],["Ne","He","Te","Ne"]]
        compatibility: function (Sire, Dam) {
          //面白配合判定
          const omoshiro_count = this.countUniqueElements(Sire[0], Dam[0]);
          const omoshiro_flag = omoshiro_count >= 7;

          //共通要素数の算出
          const common_elms = this.countCommonElements(Sire[1], Dam[0]);

          // 理論なし
          result = "";

          // 至高判定
          // const hasSameNameSpecial =
          //   Array.isArray(this.sameNameSpecialChecks) &&
          //   this.sameNameSpecialChecks.some((flag) => Boolean(flag));

          // 至高判定OKなら至高
          if (this.sameNameSpecialChecks.length > 0) {
            return "theory_07";
          }

          if (omoshiro_flag) {
            // 面白＋よくでき
            if (common_elms == 3) {
              result = "theory_03";
            }
            // 完璧
            if (common_elms == 4) {
              // 牝馬の3代目
              const mother3 = this.selected[3 + 16].name;
              // 牡馬の4代目
              const father4 = [
                this.selected[4].name,
                this.selected[5].name,
                this.selected[6].name,
                this.selected[7].name,
              ];

              let includesNum = father4.filter(function (value) {
                // 牝馬の3代目に合致する種牡馬を配列で取得
                return value === mother3;
              });

              // 4×3のみ奇跡になる。4×4×3は奇跡にならない。
              if (includesNum.length === 1) {
                // 奇跡
                result = "theory_06";
              } else {
                if (omoshiro_count == 8) {
                  // 超完璧
                  result = "theory_05";
                } else {
                  // 普通の完璧
                  result = "theory_04";
                }
              }
            }
            // 面白
            if (common_elms < 3) {
              result = "theory_01";
            }
          } else {
            // よくでき
            if (common_elms == 3) {
              result = "theory_03";
            }
            // 見事
            if (common_elms == 4) {
              result = "theory_02";
            }
          }

          return result;
        },

        // カウントした因子数を画面に表示させる
        applyManualFactors(rowIndex, factors) {
          const targetRow = Number(rowIndex);
          if (
            !Number.isInteger(targetRow) ||
            targetRow < 0 ||
            targetRow >= this.factorCd.length
          ) {
            return;
          }

          const picked = Array.isArray(factors) ? factors : [];
          const normalized = [];
          picked.forEach((value) => {
            const text = typeof value === "string" ? value.trim() : "";
            if (
              text &&
              manualFactorOptions.includes(text) &&
              !normalized.includes(text)
            ) {
              normalized.push(text);
            }
          });

          const sanitized = normalized.slice(0, 2);
          while (sanitized.length < 2) {
            sanitized.push("");
          }

          sanitized.forEach((value, index) => {
            const columnIndex = index + 1;
            const code = factorMap.get(value) ?? "00";
            this.setFactorName(targetRow, columnIndex, value);
            this.setFactorCd(targetRow, columnIndex, code);
            this.setFactorCss(
              targetRow,
              columnIndex,
              this.fillInFactorCells(code, targetRow)
            );
          });

          const selectedEntry = this.selected[targetRow];
          if (selectedEntry) {
            const updatedFactors = Array.isArray(selectedEntry.factors)
              ? [...selectedEntry.factors]
              : ["", "", ""];
            updatedFactors[1] = sanitized[0] || "";
            updatedFactors[2] = sanitized[1] || "";
            this.$set(this.selected, targetRow, {
              ...selectedEntry,
              factors: updatedFactors,
            });

            if (this.inbreedList[targetRow]?.selfInbreed) {
              this.$set(this.inbreedList, targetRow, {
                ...this.inbreedList[targetRow],
                factors: updatedFactors,
              });
              this.dispInbreedFactorCounts();
            }
          }

          this.factorNumtoString = this.dispFactorCounts(this.factorCd);

          if (typeof window !== "undefined" && window.localStorage) {
            window.localStorage.setItem("dabimasFactor", JSON.stringify(this.selected));
            window.localStorage.setItem("dabimasFactorCategory",JSON.stringify(this.category));
          }
        },

        dispFactorCounts: function (factorCdArray) {
          // 配列の中にある因子数をカウントする
          let count = {};
          for (var i = 0; i < factorCdArray.length; i++) {
            for (var j = 0; j < factorCdArray[i].length; j++) {
              var elm = factorCdArray[i][j];
              count[elm] = (count[elm] || 0) + 1;
            }
          }

          let factorNumtoString = Array.from(new Array(12).fill("00"));
          //ソートされたものを
          for (var i = 0; i < factorNumtoString.length; i++) {
            var ret = ("00" + (i + 1)).slice(-2);
            if (count[ret]) {
              factorNumtoString[i] = ("00" + count[ret]).slice(-2);
            } else {
              factorNumtoString[i] = "00";
            }
          }
          return factorNumtoString;
        },

        // Keyに該当する項目を取得する
        getValueByKey : function (data,name) {
          return data.filter(obj => obj.key === name).map(obj => obj.bros);
        },
        // カウントした子系統数を画面に表示させる
        dispCategoryCount: function () {
          const allSet = this.selected.every((e) => e) ? 0 : -1;
          return (new Set(this.category).size + allSet).toString();
        },
        // 配列を入れ替えたデータをセットする共通関数


        //血統表に埋めるために配列を入れ替える
        setDataForPedigree: function (sex, id, horseData) {
          const retDataForPedigree = Array.from(new Array(16).fill(null));

          if (horseData) {
            let bros;
            const myId = crypto.randomUUID();
            // リストで選択した性別（種牡馬 or 繁殖牝馬）をセット
            this.selectedSex = horseData.sex;
            // 空以外を選択した場合
            if (horseData.sex === "0" || (horseData.sex === "1" && id === 0)) {
              //牡馬を選択した場合 か 牝馬でも赤いところで牝馬を選択した場合
              // 0番目はデータそのものをセットする
              // retDataForPedigree[0] = {
              //   ...horseData,
              //   selectedHorse: horseData.name,
              //   uuid: myId,
              // };
              bros = this.getValueByKey(this.brosData, horseData.name);
              retDataForPedigree[0] = {
                ...horseData,
                selectedHorse: horseData.name,
                uuid: myId,
                selfSelected: true,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              // 0番目以降は祖全データ＋subName''＋使用不可フラグを設定（因子配列も念のためコピー）
              bros = this.getValueByKey(this.brosData, horseData.descendants[0].name);
              retDataForPedigree[1] = {
                ...horseData.descendants[0],
                subName: "",
                factors: [...horseData.descendants[0].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[0].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[1].name);
              retDataForPedigree[2] = {
                ...horseData.descendants[1],
                subName: "",
                factors: [...horseData.descendants[1].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[0].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[0].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[8].name);
              retDataForPedigree[3] = {
                ...horseData.descendants[8],
                subName: "",
                factors: [...horseData.descendants[8].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[8].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[2].name);
              retDataForPedigree[4] = {
                ...horseData.descendants[2],
                subName: "",
                factors: [...horseData.descendants[2].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[0].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[1].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[5].name);
              retDataForPedigree[5] = {
                ...horseData.descendants[5],
                subName: "",
                factors: [...horseData.descendants[5].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[0].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[9].name);
              retDataForPedigree[6] = {
                ...horseData.descendants[9],
                subName: "",
                factors: [...horseData.descendants[9].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[8].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[8].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[12].name);
              retDataForPedigree[7] = {
                ...horseData.descendants[12],
                subName: "",
                factors: [...horseData.descendants[12].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[12].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[3].name);
              retDataForPedigree[8] = {
                ...horseData.descendants[3],
                subName: "",
                factors: [...horseData.descendants[3].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[0].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[2].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[4].name);
              retDataForPedigree[9] = {
                ...horseData.descendants[4],
                subName: "",
                factors: [...horseData.descendants[4].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[0].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[6].name);
              retDataForPedigree[10] = {
                ...horseData.descendants[6],
                subName: "",
                factors: [...horseData.descendants[6].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[0].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[5].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[7].name);
              retDataForPedigree[11] = {
                ...horseData.descendants[7],
                subName: "",
                factors: [...horseData.descendants[7].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[0].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[10].name);
              retDataForPedigree[12] = {
                ...horseData.descendants[10],
                subName: "",
                factors: [...horseData.descendants[10].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[8].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[9].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[11].name);
              retDataForPedigree[13] = {
                ...horseData.descendants[11],
                subName: "",
                factors: [...horseData.descendants[11].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[8].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[13].name);
              retDataForPedigree[14] = {
                ...horseData.descendants[13],
                subName: "",
                factors: [...horseData.descendants[13].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[12].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[12].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[14].name);
              retDataForPedigree[15] = {
                ...horseData.descendants[14],
                subName: "",
                factors: [...horseData.descendants[14].factors],
                disabled: true,
                selectedHorse:
                  horseData.sex === "0"
                    ? horseData.name
                    : horseData.descendants[14].name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };
            } else {
              //牝馬を選択した場合
              brosHead = this.getValueByKey(this.brosData, horseData.name);
              bros = this.getValueByKey(this.brosData, horseData.descendants[0].name);
              retDataForPedigree[0] = {
                ...horseData.descendants[0],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[0].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers
                    : ["",""],
                fullSisters:
                  brosHead.length != 0
                    ? brosHead[0].fullSisters
                    : ["",""],
                childName:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[1].name);
              retDataForPedigree[1] = {
                ...horseData.descendants[1],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[1].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[0].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[8].name);
              retDataForPedigree[2] = {
                ...horseData.descendants[8],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[8].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[2].name);
              retDataForPedigree[3] = {
                ...horseData.descendants[2],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[2].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[1].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[5].name);
              retDataForPedigree[4] = {
                ...horseData.descendants[5],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[5].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[9].name);
              retDataForPedigree[5] = {
                ...horseData.descendants[9],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[9].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[8].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[12].name);
              retDataForPedigree[6] = {
                ...horseData.descendants[12],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[12].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[3].name);
              retDataForPedigree[7] = {
                ...horseData.descendants[3],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[3].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[2].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[4].name);
              retDataForPedigree[8] = {
                ...horseData.descendants[4],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[4].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[6].name);
              retDataForPedigree[9] = {
                ...horseData.descendants[6],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[6].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[5].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[7].name);
              retDataForPedigree[10] = {
                ...horseData.descendants[7],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[7].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[10].name);
              retDataForPedigree[11] = {
                ...horseData.descendants[10],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[10].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[11].name);
              retDataForPedigree[12] = {
                ...horseData.descendants[11],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[11].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[13].name);
              retDataForPedigree[13] = {
                ...horseData.descendants[13],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[13].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: horseData.descendants[12].name,
              };

              bros = this.getValueByKey(this.brosData, horseData.descendants[14].name);
              retDataForPedigree[14] = {
                ...horseData.descendants[14],
                subName: `(${horseData.name})`,
                factors: [...horseData.descendants[14].factors],
                disabled: true,
                selectedHorse:
                  brosHead.length != 0
                    ? brosHead[0].fullBrothers[0]
                    : horseData.name,
                uuid: myId,
                selfSelected: false,
                fullBrothers:
                  bros.length != 0
                    ? bros[0].fullBrothers
                    : ["",""],
                fullSisters:
                  bros.length != 0
                    ? bros[0].fullSisters
                    : ["",""],
                childName: null
              };
              retDataForPedigree[15] = "broodmares";
            }
          }
          return retDataForPedigree;
        },

        //偶数であることを確認する
        //0は例外でFalseを返す
        //1は例外でTrueを返す
        isEven: function (cellNumber) {
          switch (cellNumber) {
            case 0:
              return false;
            case 1:
              return true;
            default:
              return cellNumber % 2 === 0;
          }
        },

        // 半角→全角(英数字)
        replaceHalfToFull: function (str) {
          return str.replace(/[!-~]/g, function (s) {
            return String.fromCharCode(s.charCodeAt(0) + 0xfee0);
          });
        },

        // 親系統配列に詰めるかの判定をする
        judgeSetParentLine: function (str, cell_id) {
          let ParentLine = "";
          switch (cell_id) {
            // （+ 16）は牝馬のほう（面白系統）
            case 1:
            case 3:
            case 5:
            case 7:
            case 1 + 16:
            case 3 + 16:
            case 5 + 16:
            case 7 + 16:
              ParentLine = str ?? "";
              break;
            // 見事系統
            case 9:
            case 11:
            case 13:
            case 15:
              ParentLine = str ?? "";
              break;
            default:
              break;
          }
          return ParentLine;
        },

        // セルに因子CSSを詰める
        fillInFactorCells: function (str, cell_id) {
          if (str == "00") {
            // nullのときはデフォルトのCSSを返す
            return `${this.getCss(cell_id)} styleFactorClassMain`;
          } else {
            return `f${str} styleFactorClassMain`;
          }
        },

        // セルに因子CSSを詰める
        fillInParentLineCells: function (str, cell_id) {
          if (str == null || str === "") {
            // nullのときはデフォルトのCSSを返す
            return `${this.getCss(cell_id)} styleParentLine`;
          } else {
            return `${str} styleParentLine`;
          }
        },

        getCellIdQue: function (cellNo, horseDataList) {
          // 設定するセルの最大値を決める
          var max_cell_id = cellNo;
          while (true) {
            if (max_cell_id * 2 >= 16) {
              max_cell_id = max_cell_id + 1;
              break;
            }

            max_cell_id = max_cell_id * 2 + 1;
            if (max_cell_id * 2 > 16) {
              break;
            }

            // if (Object.keys(horseDataList[15]).length === 0) {
            if (
              horseDataList[15] === "broodmares" ||
              horseDataList[cellNo]?.subName.substring(0, 1) === "("
            ) {
              // 選択したのが繫殖牝馬だった or インブリードしたのが牝馬（赤色のところはのぞく場合）はこっちのルートに入る broodmares
              // 繫殖牝馬だった（赤色のところはのぞく場合）は16番目にNULLを設定しているので
              max_cell_id = (max_cell_id + 1) * 2;
            } else {
              max_cell_id = max_cell_id * 2;
            }
            if (max_cell_id * 2 > 16) {
              break;
            }

            while (true) {
              max_cell_id = max_cell_id * 2;
              if (max_cell_id * 2 > 16) {
                break;
              }
            }
            break;
          }

          //格納するドロップダウンリストの配列作成（初期値は選択したセル）
          var cell_id_que = [cellNo];
          var is_checked = [false];

          var i = 1;
          while (is_checked.indexOf(false) + 1) {
            // falseが最初に来るindexを取得
            var index = is_checked.indexOf(false);
            is_checked[index] = true;

            if (2 * cell_id_que[index] < max_cell_id) {
              if (
                i === 1 &&
                horseDataList[15] != "broodmares" &&
                horseDataList[cellNo]?.subName.substring(0, 1) != "("
              ) {
                // 初回でかつ 繫殖牝馬だった（赤色のところはのぞく場合）はこちらのルートに
                if (cellNo === 0) {
                  // 0のときだけ例外
                  cell_id_que.push(1);
                } else {
                  cell_id_que.push(2 * cell_id_que[index]);
                }
                is_checked.push(false);
              } else {
                cell_id_que.push(2 * cell_id_que[index]);
                cell_id_que.push(2 * cell_id_que[index] + 1);
                is_checked.push(false);
                is_checked.push(false);
              }
              i++;
            }
          }

          return cell_id_que;
        },

        // 因子名を詰め込む
        setFactorName: function (row, col, factorName) {
          if (!this.factorName[row]) {
            this.$set(this.factorName, row, ["", "", ""]);
          }
          this.$set(this.factorName[row], col, factorName ?? "");
        },

        // 因子情報を詰め込む
        setFactorCd: function (row, col, factorCd) {
          if (!this.factorCd[row]) {
            this.$set(this.factorCd, row, ["00", "00", "00"]);
          }
          this.$set(this.factorCd[row], col, factorCd ?? "00");
        },

        // 因子情報を詰め込む
        setFactorCss: function (row, col, styleFactorClass) {
          if (!this.styleFactorClasses[row]) {
            const baseCss = typeof this.getCss === "function" ? this.getCss(row) : "";
            const fallback = baseCss
              ? `${baseCss} styleFactorClassMain`
              : "styleFactorClassMain";
            this.$set(
              this.styleFactorClasses,
              row,
              [fallback, fallback, fallback]
            );
          }
          const baseCss = typeof this.getCss === "function" ? this.getCss(row) : "";
          const fallback = baseCss
            ? `${baseCss} styleFactorClassMain`
            : "styleFactorClassMain";
          this.$set(
            this.styleFactorClasses[row],
            col,
            styleFactorClass ?? fallback
          );
        },

        // 親系統を詰め込む
        setParentLine: function (row, parentLine) {
          this.$set(this.parentLines, row, parentLine);
          this.$set(
            this.styleParentLineClasses,
            row,
            this.fillInParentLineCells(parentLine, row)
          );
        },

        // 選択したセルを起点に血統データを入れる関数
        setPedigree: function (sex, cellNo, horseDataList) {
          // 詰めるためのキューを取得する
          const cell_id_que = this.getCellIdQue(cellNo, horseDataList);
          // 配列の先頭1件
          let isFirst = true;
          // 先祖に向かって血統表をセットする
          for (const cell_id of cell_id_que) {
            // 名前をセットする
            if (
              !(sex === 1 && cell_id === 0) &&
              horseDataList[cell_id_que.indexOf(cell_id)]
            ) {
              // 繁殖牝馬直のリスト選択したときはここに入ってこない
              if (
                this.horses.findIndex(
                  (object) =>
                    object?.name ===
                      horseDataList[cell_id_que.indexOf(cell_id)].name &&
                    object?.subName ===
                      horseDataList[cell_id_que.indexOf(cell_id)].subName
                ) === -1
              ) {
                // リストに無い場合は追加する
                this.stallions = [
                  ...Array.from(this.stallions),
                  { ...horseDataList[cell_id_que.indexOf(cell_id)] },
                ];
                this.horses = [
                  ...Array.from(this.horses),
                  { ...horseDataList[cell_id_que.indexOf(cell_id)] },
                ];
              }
            }

            // セットする＋自分の位置も併せてセットする
            if (horseDataList[cell_id_que.indexOf(cell_id)]) {
              this.$set(this.selected, cell_id + sex * 16, {
                ...horseDataList[cell_id_que.indexOf(cell_id)],
                index: cell_id + sex * 16,
                selfSelected: isFirst,
              });
              this.$set(
                this.category,
                cell_id + sex * 16,
                horseDataList[cell_id_que.indexOf(cell_id)].son
              );
              // 配列の先頭フラグを落とす
              isFirst = false;
            } else {
              this.$set(this.selected, cell_id + sex * 16, null);
              this.$set(this.category, cell_id + sex * 16, null);
            }

            // 配列に因子名を詰め込む
            // horseDataList[i]がnullの場合、horseDataList[cell_id_que.indexOf(cell_id)]?.factors[0]がundefinedとなるので、''を返却する
            this.setFactorName(
              cell_id + sex * 16,
              0,
              horseDataList[cell_id_que.indexOf(cell_id)]?.factors[0] ?? ""
            );
            this.setFactorName(
              cell_id + sex * 16,
              1,
              horseDataList[cell_id_que.indexOf(cell_id)]?.factors[1] ?? ""
            );
            this.setFactorName(
              cell_id + sex * 16,
              2,
              horseDataList[cell_id_que.indexOf(cell_id)]?.factors[2] ?? ""
            );

            // 配列に因子情報を詰め込む
            // horseDataList[i]がnullの場合、horseDataList[cell_id_que.indexOf(cell_id)]?.factors[0]がundefinedとなるので、'00'を返却する
            this.setFactorCd(
              cell_id + sex * 16,
              0,
              factorMap.get(
                horseDataList[cell_id_que.indexOf(cell_id)]?.factors[0]
              ) ?? "00"
            );
            this.setFactorCd(
              cell_id + sex * 16,
              1,
              factorMap.get(
                horseDataList[cell_id_que.indexOf(cell_id)]?.factors[1]
              ) ?? "00"
            );
            this.setFactorCd(
              cell_id + sex * 16,
              2,
              factorMap.get(
                horseDataList[cell_id_que.indexOf(cell_id)]?.factors[2]
              ) ?? "00"
            );

            // 因子css
            this.setFactorCss(
              cell_id + sex * 16,
              0,
              this.fillInFactorCells(
                this.factorCd[cell_id + sex * 16][0],
                cell_id + sex * 16
              )
            );
            this.setFactorCss(
              cell_id + sex * 16,
              1,
              this.fillInFactorCells(
                this.factorCd[cell_id + sex * 16][1],
                cell_id + sex * 16
              )
            );
            this.setFactorCss(
              cell_id + sex * 16,
              2,
              this.fillInFactorCells(
                this.factorCd[cell_id + sex * 16][2],
                cell_id + sex * 16
              )
            );

            // 親系統
            this.setParentLine(
              cell_id + sex * 16,
              this.judgeSetParentLine(
                horseDataList[cell_id_que.indexOf(cell_id)]?.parentLine,
                cell_id + sex * 16
              )
            );
          }

          // 子孫に選択した種牡馬のＮ薄めを血統データに入れる
          let reverseNum = cellNo;
          let reverseCnt = 0;
          const name = horseDataList[0]?.name;
          const subName = horseDataList[0]?.subName;
          const parentLine = horseDataList[0]?.parentLine;
          const uuid = horseDataList[0]?.uuid;
          const son = horseDataList[0]?.son;
          while (this.isEven(reverseNum)) {
            // 2で割る
            reverseNum = Math.floor(reverseNum / 2);

            if (name) {
              // 追加モード
              reverseCnt++;
              // 自家製種牡馬名
              const handMadeName = `★${this.replaceHalfToFull(
                reverseCnt.toString(10)
              )}薄め${name.trim()}${subName.trim()}`;
              if (reverseNum === 0 && sex === 1) {
                // 自家製牝馬をセット
                this.broodmares = [
                  ...Array.from(this.broodmares),
                  {
                    name: "ワタシノヒンバ",
                    subName: "",
                    disabled: true,
                    factors: Array.from(new Array(3).fill("")),
                    fullBrothers: Array.from(new Array(2).fill("")),
                    fullSisters: Array.from(new Array(2).fill("")),
                    uuid: uuid,
                  },
                ];
                this.selected[reverseNum + sex * 16] = {
                  name: "ワタシノヒンバ",
                  subName: "",
                  disabled: true,
                  index: reverseNum + sex * 16,
                  factors: Array.from(new Array(3).fill("")),
                  fullBrothers: Array.from(new Array(2).fill("")),
                  fullSisters: Array.from(new Array(2).fill("")),
                  uuid: uuid,
                  selfSelected: false,
                };
                // 子系統をセット
                this.category[reverseNum + sex * 16] = son;
              } else {
                // 名前をセット
                this.horses = [
                  ...Array.from(this.horses),
                  {
                    name: handMadeName,
                    subName: "",
                    parentLine: parentLine,
                    factors: Array.from(new Array(3).fill("")),
                    fullBrothers: Array.from(new Array(2).fill("")),
                    fullSisters: Array.from(new Array(2).fill("")),
                    disabled: true,
                    uuid: uuid,
                  },
                ];
                this.stallions = [
                  ...Array.from(this.horses),
                  {
                    name: handMadeName,
                    subName: "",
                    parentLine: parentLine,
                    factors: Array.from(new Array(3).fill("")),
                    fullBrothers: Array.from(new Array(2).fill("")),
                    fullSisters: Array.from(new Array(2).fill("")),
                    disabled: true,
                    uuid: uuid,
                  },
                ];
                this.selected[reverseNum + sex * 16] = {
                  name: handMadeName,
                  subName: "",
                  parentLine: parentLine,
                  factors: Array.from(new Array(3).fill("")),
                  fullBrothers: Array.from(new Array(2).fill("")),
                  fullSisters: Array.from(new Array(2).fill("")),
                  disabled: true,
                  index: reverseNum + sex * 16,
                  uuid: uuid,
                  selfSelected: false,
                };
                // 親系統を設定する
                this.setParentLine(
                  reverseNum + sex * 16,
                  this.judgeSetParentLine(parentLine, reverseNum + sex * 16)
                );
                // 子系統をセット
                this.category[reverseNum + sex * 16] = son;
              }
            }
            // 配列に因子名を詰め込む
            this.setFactorName(reverseNum + sex * 16, 0, "");
            this.setFactorName(reverseNum + sex * 16, 1, "");
            this.setFactorName(reverseNum + sex * 16, 2, "");
            // 配列に因子情報を詰め込む
            this.setFactorCd(reverseNum + sex * 16, 0, "00");
            this.setFactorCd(reverseNum + sex * 16, 1, "00");
            this.setFactorCd(reverseNum + sex * 16, 2, "00");
            // 因子css
            this.setFactorCss(
              reverseNum + sex * 16,
              0,
              this.fillInFactorCells(
                this.factorCd[reverseNum + sex * 16][0],
                reverseNum + sex * 16
              )
            );
            this.setFactorCss(
              reverseNum + sex * 16,
              1,
              this.fillInFactorCells(
                this.factorCd[reverseNum + sex * 16][1],
                reverseNum + sex * 16
              )
            );
            this.setFactorCss(
              reverseNum + sex * 16,
              2,
              this.fillInFactorCells(
                this.factorCd[reverseNum + sex * 16][2],
                reverseNum + sex * 16
              )
            );
          }

          // 最後に配列に馬リストの配列にセットする
          this.horseDataLists = [this.horses, this.stallions, this.broodmares];
        },
      },
    });
  </script>
</html>
